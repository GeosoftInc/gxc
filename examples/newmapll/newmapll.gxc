//===========================================================================
NAME          = "Create a new map with lat-long limits"
#include <version.gxh>

DESCRIPTION   = "

	NEWMAPLL	.MAP				map name
				.MIN_LON,		ranges
				.MIN_LAT, 
				.MAX_LON, 
				.MAX_LAT  
				.IPJ_NAME       Projection information in GXF format.
				.IPJ_DATUM         
				.IPJ_METHOD        See GXF documentation for details
				.IPJ_UNITS         on formatting these parameters.
				.IPJ_LOCALDATUM    
				.TEMPLATE		template name from MAPTMPL.INI
				.SCALE			map scale, blank for default
				.UNITS         user units per metre
				.ROTATE        add warp to rotate center of map to N-S? 
									0: No, 1: Yes (default)
"

TRANSLATIONDOMAIN = "core"
TRANSLATIONFRIENDLYPATH = "GX/Map"

// Revision History
// v9.1.0: Refactor - CORE-4552
// v7.0.0: Switch to new GX.Net projection wizard.
// v5.1.6: Added rotation as an option, instead of forcing it every time.
// v5.1.5: Can create map directly from geographic (lat, long) channels,
//         or a lat/long grid by setting up a default PCS.
//===========================================================================

RESOURCE = "newmapll.gr"
#include "newmapll.grh"
#include <all.gxh>

//===========================================================================

string(STR_FILE)  sMap, sFile, sMdf;
string(STR_DEFAULT_LONG) sSize;
string(STR_DEFAULT) sTmpl,sSet;
string(STR_DEFAULT_SHORT) sMinLon, sMinLat, sMaxLon, sMaxLat;

EDB   EData;
MAP   Map;
MVIEW View;
DGW   Diag;
LST   List;
REG   MapReg, ParmReg;
SBF   hSBF;
BF    hBF;
IPJ   hIPJ, hIPJ2;
PJ    hPJ;
LTB   hUNI;
LTB   hMED;
LTB   hTMP;
PLY   hPLY,hPLYo;
VV    hVVx1,hVVx2,hVVy1,hVVy2;   // for the warp calculation
int   i, iNext, iRet, iRet2;

real  r;
real  rMinX;     // Minimum X of map area (ground units)
real  rMaxX;     // Maximum X of map area (ground units)
real  rMinY;     // Minimum Y of map area (ground units)
real  rMaxY;     // Maximum Y of map area (ground units) 

real  rMinLon;  // Minimum Longitude of map area
real  rMaxLon;  // Maximum Longitude of map area
real  rMinLat;   // Minimum Latitude of map area
real  rMaxLat;   // Maximum Latitude of map area

int   iPort;     // Portrait map? (or landscape) (FALSE by default)
int   iExact;    // Map is exactly sized to area? 
// (or trimmed to data and margins) (FALSE by default)
int   iRot;      // Rotate map so center is N-S (TRUE by default)

real  rScale;    // Map scale (rDummy for default)
real  rConv;     // Conversion factor (to meters/unit) (rDummy for default)
real  rMargXmin; // Minimum X of margin area 
real  rMargXmax; // Maximum X of margin area 
real  rMargYmin; // Minimum Y of margin area 
real  rMargYmax; // Maximum Y of margin area                  
real  rInside;   // Inside edge
real  rDist;

string(STR_DEFAULT_SHORT) sTemp,sUnits;
string(STR_DEFAULT_LONG) s1,s2,s3,s4,s5;
string(STR_FILE) sGrid, sDB;
real rX, rY, rX1, rX2, rY1, rY2, rRot;
int iDescr,iFactor;
int iSizeXF;
int iSizeYF;
int iNameF;
int iLayoutF;
int iMediaF;
int iTypeF;
int iFixedF;
int iMargin_InsideF;
int iMargin_BottomF;
int iMargin_RightF;
int iMargin_TopF;
int iMargin_LeftF;
int iUpDirF;
int iUpAngF;
int iTmp,iMed;

#define NEWMAP "NEWMAPLL"

#define RANGE_DIALOG 0
#define SCAN_DATABASE 2
#define SCAN_GRID     3
#define COORD_SYS     4
#define SCAN_MAP      5  // TODO ?
#define NEWMAP_DIALOG 1
#define DONE         99
#define SCALE_BUTTON  6
#define TEMPLATES     7
#define SETUP_ROTATION 8

#define SETUP_FROM_XYRANGE_PARAMETERS \
			rMinLon = rGetReal_SYS("XYRANGE","MIN_LON");\
			rMinLat = rGetReal_SYS("XYRANGE","MIN_LAT");\
			rMaxLon = rGetReal_SYS("XYRANGE","MAX_LON");\
			rMaxLat = rGetReal_SYS("XYRANGE","MAX_LAT");\
			if (rMinLon > rMaxLon) {r = rMinLon; rMinLon = rMaxLon; rMaxLon = r;}\
			if (rMinLat > rMaxLat) {r = rMinLat; rMinLat = rMaxLat; rMaxLat = r;}\
			FormatR_STR(rMinLon, sMinLon, 12, 5);\
			FormatR_STR(rMinLat, sMinLat, 12, 5);\
			FormatR_STR(rMaxLon, sMaxLon, 12, 5);\
			FormatR_STR(rMaxLat, sMaxLat, 12, 5);\
			SetString_SYS(NEWMAP,"MIN_LON", sMinLon);\
			SetString_SYS(NEWMAP,"MIN_LAT", sMinLat);\
			SetString_SYS(NEWMAP,"MAX_LON", sMaxLon);\
			SetString_SYS(NEWMAP,"MAX_LAT", sMaxLat);

//===========================================================================

{

	// --- get SBF for projection info ---

	hSBF = hGetSYS_SBF();


	// --- Load Tables ---

	hTMP = CreateCSV_LTB("maptmpl");
	iNameF = iFindField_LTB(hTMP,"Name");
	iLayoutF = iFindField_LTB(hTMP,"Layout");
	iMediaF = iFindField_LTB(hTMP,"Media");
	iTypeF = iFindField_LTB(hTMP,"Type");
	iFixedF = iFindField_LTB(hTMP,"Fixed");
	iMargin_InsideF = iFindField_LTB(hTMP,"Margin_Inside");
	iMargin_BottomF = iFindField_LTB(hTMP,"Margin_Bottom");
	iMargin_RightF = iFindField_LTB(hTMP,"Margin_Right");
	iMargin_TopF = iFindField_LTB(hTMP,"Margin_Top");
	iMargin_LeftF = iFindField_LTB(hTMP,"Margin_Left");
	iUpDirF = iFindField_LTB(hTMP,"Up_Dir");
	iUpAngF = iFindField_LTB(hTMP,"Up_Ang");

	if (iNameF         ==-1) Abort_SYS(_("The [Name] not found in maptmpl table."));
	if (iLayoutF       ==-1) Abort_SYS(_("The [Layout] not found in maptmpl table."));
	if (iMediaF        ==-1) Abort_SYS(_("The [Media] not found in maptmpl table."));
	if (iTypeF         ==-1) Abort_SYS(_("The [Type] not found in maptmpl table."));
	if (iFixedF        ==-1) Abort_SYS(_("The [Fixed] not found in maptmpl table."));
	if (iMargin_InsideF==-1) Abort_SYS(_("The [Margin_Inside] not found in maptmpl table."));
	if (iMargin_BottomF==-1) Abort_SYS(_("The [Margin_Bottom] not found in maptmpl table."));
	if (iMargin_RightF ==-1) Abort_SYS(_("The [Margin_Right] not found in maptmpl table."));
	if (iMargin_TopF   ==-1) Abort_SYS(_("The [Margin_Top] not found in maptmpl table."));
	if (iMargin_LeftF  ==-1) Abort_SYS(_("The [Margin_Left] not found in maptmpl table."));
	if (iUpDirF        ==-1) Abort_SYS(_("The [Up_Dir] not found in maptmpl table."));
	if (iUpAngF        ==-1) Abort_SYS(_("The [Up_Ang] not found in maptmpl table."));

	hUNI = CreateCSV_LTB("units");
	iDescr  = iFindField_LTB(hUNI,"Description");
	iFactor = iFindField_LTB(hUNI,"Factor");
	if (iDescr==-1) Abort_SYS(_("The [Description] not found in units table."));
	if (iFactor==-1) Abort_SYS(_("The [Factor] not found in units table."));

	hMED = Create_LTB("media",LTB_TYPE_HEADER,LTB_DELIM_COMMA,"");
	iSizeXF = iFindField_LTB(hMED,"Size_X");
	iSizeYF = iFindField_LTB(hMED,"Size_Y");
	if (iSizeXF==-1) Abort_SYS(_("The [Size_X] not found in media table."));
	if (iSizeYF==-1) Abort_SYS(_("The [Size_Y] not found in media table."));

	hIPJ = Create_IPJ();
	hIPJ2 = Create_IPJ();

	// -- Create clipping polygon ---

	hPLY = Create_PLY();
	hPLYo = Create_PLY();


	// --- Create Warp VVs ---

	hVVx1 = Create_VV(REAL, 0);
	hVVy1 = Create_VV(REAL, 0);
	hVVx2 = Create_VV(REAL, 0);
	hVVy2 = Create_VV(REAL, 0);

	SetLen_VV(hVVx1, 2);
	SetLen_VV(hVVx2, 2);
	SetLen_VV(hVVy1, 2);
	SetLen_VV(hVVy2, 2);

	rMinX = rMinY = rMaxX = rMaxY = 0.0;   // stop compile warning

	iRot = 1;      // Rotate maps by default so center is N-S

	
	// --- Save initial parameters ---

	ParmReg = Create_REG(64);
	GetREG_SYS(ParmReg, NEWMAP);


	// --- Interactive Mode ---   

	if (iInteractive_SYS()) 
	{
		i = RANGE_DIALOG;
		while (i != DONE) 
		{
			switch (i) 
			{
				case RANGE_DIALOG:

			      // --- get projection ---

					GetString_SYS(NEWMAP, "IPJ_NAME", s1);
					if (iStrlen_STR(s1) > 0)
					{
						GetString_SYS(NEWMAP, "IPJ_DATUM", s2);
						GetString_SYS(NEWMAP, "IPJ_METHOD", s3);
						GetString_SYS(NEWMAP, "IPJ_UNITS", s4);
						GetString_SYS(NEWMAP, "IPJ_LOCALDATUM", s5);
						SetGXF_IPJ(hIPJ, s1, s2, s3, s4, s5);
					}

					Diag = Create_DGW("NEWMAPLL_RANGE");

					SetInfoSYS_DGW(Diag,_NEWMAPLL_RANGE_0,DGW_TEXT,NEWMAP,"MIN_LON");     
					SetInfoSYS_DGW(Diag,_NEWMAPLL_RANGE_1,DGW_TEXT,NEWMAP,"MIN_LAT");     
					SetInfoSYS_DGW(Diag,_NEWMAPLL_RANGE_2,DGW_TEXT,NEWMAP,"MAX_LON");    
					SetInfoSYS_DGW(Diag,_NEWMAPLL_RANGE_3,DGW_TEXT,NEWMAP,"MAX_LAT");
					SetInfoSYS_DGW(Diag,_NEWMAPLL_RANGE_4,DGW_LISTALIAS,NEWMAP,"ROTATE");
					GetName_IPJ(hIPJ,IPJ_NAME_PCS,s1);    
					SetInfo_DGW(Diag,_NEWMAPLL_RANGE_5,DGW_TEXT,s1);    

					iRet = iRunDialogue_DGW(Diag);
					if (iRet == -1) 
					{
						ClearGroupParm_SYS(NEWMAP);	// Restore original parameters
						SetREG_SYS(ParmReg);	
						Cancel_SYS();
					}

					GetInfoSYS_DGW(Diag,_NEWMAPLL_RANGE_0,DGW_TEXT,NEWMAP,"MIN_LON");     
					GetInfoSYS_DGW(Diag,_NEWMAPLL_RANGE_1,DGW_TEXT,NEWMAP,"MIN_LAT");     
					GetInfoSYS_DGW(Diag,_NEWMAPLL_RANGE_2,DGW_TEXT,NEWMAP,"MAX_LON");    
					GetInfoSYS_DGW(Diag,_NEWMAPLL_RANGE_3,DGW_TEXT,NEWMAP,"MAX_LAT");    
					GetInfoSYS_DGW(Diag,_NEWMAPLL_RANGE_4,DGW_LISTALIAS,NEWMAP,"ROTATE");
					Destroy_DGW(Diag);

               if (iRet == SCAN_DATABASE)
					{ 
						while(TRUE)
						{
							// --- If no database is defined, use the current database ---

							if(iHaveCurrent_EDB() == 1)
							{
								EData = Current_EDB();
								GetName_EDB(EData, sDB);
							}
							else
							{
								GetString_SYS(NEWMAP,"DATABASE", sDB);


								if (iFileOpen_GUI(_("Select database"), FILE_FILTER_GDB, sDB, sDB) == 1)
									break;	// return to main dialog

								EData = Load_EDB(sDB);
							}
							
							if (iRunGX_SYS("rangedb"))
							{
								DisplayMessage_SYS(_("rangedb GX"),_("Failed to calculate range from database."));
								UnLoad_EDB(sDB);		// unload so you can scan for another
								continue;
							}                


							// --- get projection ---
                                       
							if (iExistFile_SBF(hSBF,"_xyrange.ipj")) 
							{
								hBF = CreateSBF_BF(hSBF,"_xyrange.ipj",BF_READ);
								Destroy_IPJ(hIPJ2);
								hIPJ2 = CreateS_IPJ(hBF);
								DestroyEx_BF(hBF);

								if (iSourceType_IPJ(hIPJ2) != IPJ_TYPE_PCS && iSourceType_IPJ(hIPJ2) != IPJ_TYPE_GCS) 
								{
									DisplayMessage_SYS(_("Scanning database"),_("The database does not have a projected or geographic coordinate system"));
									break;
								}
								else
									Copy_IPJ(hIPJ2, hIPJ);

								GetGXF_IPJ(hIPJ, s1, s2, s3, s4, s5);
								SetString_SYS(NEWMAP, "IPJ_NAME", s1);
								SetString_SYS(NEWMAP, "IPJ_DATUM", s2);
								SetString_SYS(NEWMAP, "IPJ_METHOD", s3);
								SetString_SYS(NEWMAP, "IPJ_UNITS", s4);
								SetString_SYS(NEWMAP, "IPJ_LOCALDATUM", s5);  
							}

							SETUP_FROM_XYRANGE_PARAMETERS

	
							// --- Create a default PCS if we are in Lat-Long ---
							                     
							if (iSourceType_IPJ(hIPJ) == IPJ_TYPE_GCS) 
							{
                        if ((rMaxLon - rMinLon) > 180.0)
                        {
      							DisplayMessage_SYS(_("Scan Database"),_("The database coordinates are geographic with a longitude range > 180 degrees.\r\nCannot create a default projected coordinate system."));
                           break;
                        }

								MakeProjected_IPJ(hIPJ, rMinLon, rMinLat, rMaxLon, rMaxLat);
								DisplayMessage_SYS(_("Scan Database"),_("The database coordinates are geographic.\r\nCreating a default projected coordinate system."));
							}

							SetString_SYS(NEWMAP,"DATABASE", sDB);
							break;
						}
					}
				
					else if (iRet == SCAN_GRID) 
					{
						while(TRUE)
						{
							GetString_SYS(NEWMAP, "GRID", sGrid);
							if (iDatFileForm_GUI(_("Select grid"), sGrid, sGrid, DAT_TYPE_GRID, FILE_FORM_OPEN, FALSE) == 1)
								break;  // return to main dialog

							SetString_SYS("IMGRANGE","FILE", sGrid);
							SetString_SYS("IMGRANGE","compute_lat_long","1");    

							if (iRunGX_SYS("imgrange.gx"))
							{
								DisplayMessage_SYS(_("imgrange GX"),_("Failed to calculate range from grid."));
								continue;
							}


							// --- get projection ---

							if (iExistFile_SBF(hSBF,"_xyrange.ipj")) 
							{
								hBF = CreateSBF_BF(hSBF,"_xyrange.ipj",BF_READ);
								Destroy_IPJ(hIPJ2);
								hIPJ2 = CreateS_IPJ(hBF);
								DestroyEx_BF(hBF);

								if (iSourceType_IPJ(hIPJ2) != IPJ_TYPE_PCS && iSourceType_IPJ(hIPJ2) != IPJ_TYPE_GCS) 
								{
									DisplayMessage_SYS(_("Scanning grid"),_("The grid does not have a projected or geographic coordinate system"));
									continue;
								}                    
								else
									Copy_IPJ(hIPJ2, hIPJ);

								GetGXF_IPJ(hIPJ, s1, s2, s3, s4, s5);
								SetString_SYS(NEWMAP, "IPJ_NAME", s1);
								SetString_SYS(NEWMAP, "IPJ_DATUM", s2);
								SetString_SYS(NEWMAP, "IPJ_METHOD", s3);
								SetString_SYS(NEWMAP, "IPJ_UNITS", s4);
								SetString_SYS(NEWMAP, "IPJ_LOCALDATUM", s5);  
							}

							SETUP_FROM_XYRANGE_PARAMETERS

						
							// --- Create a default PCS if we are in Lat-Long ---

							if (iSourceType_IPJ(hIPJ) == IPJ_TYPE_GCS) 
							{
								MakeProjected_IPJ(hIPJ, rMinLon, rMinLat, rMaxLon, rMaxLat);
								DisplayMessage_SYS(_("Scan Grid"),_("The grid coordinates are geographic.\r\nCreating a default projected coordinate system."));
							}

							SetString_SYS(NEWMAP,"GRID", sGrid);                     
							break;
						}
					}
					else if (iRet == COORD_SYS) 
					{
						i = COORD_SYS;
						iNext = RANGE_DIALOG;
						break;
					}   

					else if (iRet == NEWMAP_DIALOG)
					{
						// --- Do Validation before moving to the next dialog ---

						// --- if no projection, get one ---

						rMinLon = rGetReal_SYS(NEWMAP,"MIN_LON");
						rMinLat = rGetReal_SYS(NEWMAP,"MIN_LAT");
						rMaxLon = rGetReal_SYS(NEWMAP,"MAX_LON");
						rMaxLat = rGetReal_SYS(NEWMAP,"MAX_LAT");

                  if (rMinLon == rDUMMY || rMaxLon == rDUMMY || rMinLon >= rMaxLon) 
						{
                     DisplayMessage_SYS(_("Invalid range"),_("Invalid longitude range."));
							break;
						}
                  else if (rMinLat == rDUMMY || rMaxLat == rDUMMY || rMinLat >= rMaxLat) 
						{
                     DisplayMessage_SYS(_("Invalid range"),_("Invalid latitude range."));
							break;
						}
						
						if(iSourceType_IPJ(hIPJ)==IPJ_TYPE_GCS) 
						{
							DisplayMessage_SYS(_("Geographic coordinate system"),_("Creating a default projected coordinate system."));
							MakeProjected_IPJ(hIPJ, rMinLon, rMinLat, rMaxLon, rMaxLat);
						}
						else if (iSourceType_IPJ(hIPJ) != IPJ_TYPE_PCS) 
						{							
							i = COORD_SYS;
							iNext = SETUP_ROTATION;
							break;
						}

						i = SETUP_ROTATION;
					}
					break;

				case COORD_SYS:

					// --- Edit/modify the IPJ ---

					if(iCoordSysWizard_GUI(hIPJ, TRUE, COORDSYS_MODE_PCS, _("Map view"), "*Data") == 0)
					{
						GetGXF_IPJ(hIPJ, s1, s2, s3, s4, s5);
						SetString_SYS(NEWMAP, "IPJ_NAME", s1);
						SetString_SYS(NEWMAP, "IPJ_DATUM", s2);
						SetString_SYS(NEWMAP, "IPJ_METHOD", s3);
						SetString_SYS(NEWMAP, "IPJ_UNITS", s4);
						SetString_SYS(NEWMAP, "IPJ_LOCALDATUM", s5);  
					}

					i = iNext;
					break;

				case SETUP_ROTATION:  // template setup


					// --- Rotate map? ---

					iRot = iGetInt_SYS(NEWMAP,"ROTATE");
					if(iRot!=0) iRot = 1;   // Rotate by default


					// --- Find rotation necessary to make the center of the
					//     map aligned N-S ---

					hPJ = CreateIPJ_PJ((IPJ)0, hIPJ);  // to go from LL to data
					rX1 = 0.5 * (rMinLon + rMaxLon);
					rY1 = rMinLat;
					ConvertXY_PJ(hPJ,rX1,rY1);
					rX2 = 0.5 * (rMinLon + rMaxLon);
					rY2 = rMaxLat;
					ConvertXY_PJ(hPJ,rX2,rY2);

					rRot = 0.0;
					if(iRot)
						rRot = 90.0 - rArcTan2_MATH(rY2-rY1, rX2-rX1)*57.29577951;

					// --- Save original top/bottom positions for warp ---

					SetReal_VV(hVVx1, 0, rX1);
					SetReal_VV(hVVy1, 0, rY1);
					SetReal_VV(hVVx1, 1, rX2);
					SetReal_VV(hVVy1, 1, rY2);

					// --- Create a clipping polygon along the lat-long boundary. ---

					Clear_PLY (hPLY);
					ClipPLY_PJ(hPJ, rMinLon, rMinLat, rMaxLon, rMaxLat, 0.5, hPLY);
					Copy_PLY(hPLYo,hPLY);
					SaveTable_PLY(hPLYo,"_LLMask.ply");

					// --- Rotate the PLY about the center, and get the range in X and Y ---

					rX = 0.5*(rX1 + rX2);
					rY = 0.5*(rY1 + rY2);
					Rotate_PLY(hPLY, rX, rY, rRot);

					Extent_PLY(hPLY, rMinX, rMinY, rMaxX, rMaxY);


					// --- Save new top/bottom positions for warp ---

					rDist = rSqrt_MATH((rX2-rX1)*(rX2-rX1) + (rY2-rY1)*(rY2-rY1))/2.0;
					rX1 = rX;
					rX2 = rX;
					rY1 = rY - rDist;
					rY2 = rY + rDist;
					SetReal_VV(hVVx2, 0, rX1);
					SetReal_VV(hVVy2, 0, rY1);
					SetReal_VV(hVVx2, 1, rX2);
					SetReal_VV(hVVy2, 1, rY2);

					if ((rMinX == rDUMMY) || (rMinX >= rMaxX)) {
						DisplayMessage_SYS(_("Invalid range"),_("Invalid X range."));
						i = RANGE_DIALOG;
					} else if ((rMinY == rDUMMY) || (rMinY >= rMaxY)) {
						DisplayMessage_SYS(_("Invalid range"),_("Invalid Y range."));
						i = RANGE_DIALOG;
					} else
						i = NEWMAP_DIALOG;

					break;

				case NEWMAP_DIALOG:

					Diag = Create_DGW("NEWMAPLL_CREATE");
					List = GetList_DGW(Diag,_NEWMAPLL_CREATE_1);

					// TODO - WHY?
					iTmp = iFindItem_LST(List, LST_ITEM_NAME, _("landscape letter")); 
					if (iTmp != -1)
						DelItem_LST(List, iTmp);
					GetLST_LTB(hTMP,0,List);
					Sort_LST(List,0,0);


					SetInfoSYS_DGW(Diag,_NEWMAPLL_CREATE_0,DGW_FILEPATH,NEWMAP,"MAP");     
					SetInfoSYS_DGW(Diag,_NEWMAPLL_CREATE_1,DGW_TEXT,NEWMAP,"TEMPLATE");     
					SetInfoSYS_DGW(Diag,_NEWMAPLL_CREATE_2,DGW_TEXT,NEWMAP,"SCALE");     
					GetName_IPJ(hIPJ,IPJ_NAME_PCS,s1);    
					SetInfo_DGW(Diag,_NEWMAPLL_CREATE_3,DGW_TEXT,s1);    
					GetName_IPJ(hIPJ,IPJ_NAME_UNIT_FULL,s1);    
					SetInfo_DGW(Diag,_NEWMAPLL_CREATE_4,DGW_TEXT,s1);    

					iRet = iRunDialogue_DGW(Diag);
					if (iRet == -1) 
					{
						ClearGroupParm_SYS(NEWMAP);	// Restore original parameters
						SetREG_SYS(ParmReg);	
						Cancel_SYS();
					}

					GetInfoSYS_DGW(Diag,_NEWMAPLL_CREATE_0,DGW_FILEPATH,NEWMAP,"MAP");     
					GetInfoSYS_DGW(Diag,_NEWMAPLL_CREATE_1,DGW_TEXT,NEWMAP,"TEMPLATE");     
					GetInfoSYS_DGW(Diag,_NEWMAPLL_CREATE_2,DGW_TEXT,NEWMAP,"SCALE");     
					Destroy_DGW(Diag);


					// --- Go back? ---

					if (iRet == RANGE_DIALOG) 
					{
						i = RANGE_DIALOG;
						break;
					}

					if (iRet == TEMPLATES) 
					{
						// --- edit templates ---

						GetString_SYS(NEWMAP,"TEMPLATE",sTmpl);
						SetString_SYS("MAPTMPL","NAME",sTmpl);
						Destroy_SYS(hTMP);

						iRet2 = iRunGX_SYS("maptmpl.gx");
						if (iRet2 == 0) 
						{
							GetString_SYS("MAPTMPL","NAME",sTmpl);
							SetString_SYS(NEWMAP,"TEMPLATE",sTmpl);
						}
						hTMP = CreateCSV_LTB("maptmpl");
						iRet = SCALE_BUTTON;
					}


					// --- get unit factor ---

					rConv = 1.0;                     
					GetUnits_IPJ(hIPJ,rConv,sUnits);
					if (rConv <= 0.0) 
						Abort_SYS(_("Invalid unit conversion factor in UNITS table."));


					// --- get template parameters ---

					GetString_SYS(NEWMAP,"TEMPLATE",sTmpl);
					iTmp = iFindKey_LTB(hTMP,sTmpl);
					if (iTmp < 0) {
						DisplayMessage_SYS(_("No template"),_("Template not found"));
						break;
					}


					// --- layout ---

					GetString_LTB(hTMP,iTmp,iLayoutF,sSet);
					if (iStrStr_STR(sSet, _("portrait"), STR_CASE_TOLERANT) != -1)
						iPort = TRUE;
					else         
						iPort = FALSE;


					// --- exact size ---

					GetString_LTB(hTMP,iTmp,iFixedF,sSet);
					if (iStrStr_STR(sSet, _("fixed"), STR_CASE_TOLERANT) != -1)
						iExact = TRUE;
					else         
						iExact = FALSE;


					// --- margins ---

					rMargXmin = rGetReal_LTB(hTMP,iTmp,iMargin_LeftF);
					rMargXmax = rGetReal_LTB(hTMP,iTmp,iMargin_RightF);
					rMargYmin = rGetReal_LTB(hTMP,iTmp,iMargin_BottomF);
					rMargYmax = rGetReal_LTB(hTMP,iTmp,iMargin_TopF);
					rInside   = rGetReal_LTB(hTMP,iTmp,iMargin_InsideF);


					// --- media string ---

					GetString_LTB(hTMP,iTmp,iMediaF,sSet);
					iMed = iFindKey_LTB(hMED,sSet);
					if (iMed < 0) {
						DisplayMessage_SYS(_("Media not found"),_("Media not defined"));
						break;
					}
					GetString_LTB(hMED,iMed,iSizeXF,sSet);
					Strcpy_STR(sSize,sSet);
					Strcat_STR(sSize,",");
					GetString_LTB(hMED,iMed,iSizeYF,sSet);
					Strcat_STR(sSize,sSet);


					// --- calculate a size for unlimited size ---

               rScale = rDUMMY;
               if (iRet != SCALE_BUTTON && iExistReal_SYS(NEWMAP,"SCALE"))
                  rScale = rGetReal_SYS(NEWMAP,"SCALE");

					if (iStrMin_STR(sSize) == 1) 
					{
                  if ((rScale==rDUMMY) || (rScale <= 0.0)) {
                     DisplayMessage_SYS(_("Scale error"), _("Unlimited media size requires a valid scale."));
							break;
						}


                  // --- Calculate the required paper size ---
                  
						rX = 100.0 * rConv * (rMaxX - rMinX) / rScale + 2.0*rInside + rMargXmax + rMargXmin + 0.25;
						rY = 100.0 * rConv * (rMaxY - rMinY) / rScale + 2.0*rInside + rMargYmax + rMargYmin + 0.25;
						FormatR2_STR(rX, sTemp, 10, 2);
						Strcpy_STR(sSize, sTemp);
						Strcat_STR(sSize, ",");
						FormatR2_STR(rY, sTemp, 10, 2);
						Strcat_STR(sSize, sTemp);                   


						// --- Set Portrait parameter depending on relative X and Y sizes ---

                  if(rMaxY-rMinY > rMaxX-rMinX)
                     iPort = 1;
                  else
                     iPort = 0;
					}

					if (iRet == SCALE_BUTTON) 
					{
						iMapsetTest_MVU(rMinX,rMaxX,rMinY,rMaxY,sSize,iPort,iExact,
							rScale,1.0/rConv,rMargXmin,rMargXmax,rMargYmin,rMargYmax,rInside);
						SetReal_SYS(NEWMAP,"SCALE",rScale);
						break;
					} 
					else 
					{ 
						if (!iMapsetTest_MVU(rMinX,rMaxX,rMinY,rMaxY,sSize,iPort,iExact,rScale,1.0/rConv,rMargXmin,rMargXmax,rMargYmin,rMargYmax,rInside))
						{
							ShowError_SYS();
							break;
						}
					}               

					// --- check that map does not exist ---

					GetString_SYS(NEWMAP,"MAP",sMap);
					if (iStrlen_STR(sMap)==0)
					{
						DisplayMessage_SYS(_("Map name required"),_("A map name is required."));
						break;
					}
					UnLoad_EMAP(sMap);	// harmless if map is not loaded


					// --- done ---

					i = DONE;
					break;

				default:

					DisplayInt_SYS(_("I'm lost"),i);            
					i = RANGE_DIALOG;
					break;
			}            
		}

		// --- Save projection parameters for scripting ---

		GetGXF_IPJ(hIPJ, s1, s2, s3, s4, s5);
		SetString_SYS(NEWMAP, "IPJ_NAME", s1);
		SetString_SYS(NEWMAP, "IPJ_DATUM", s2);
		SetString_SYS(NEWMAP, "IPJ_METHOD", s3);
		SetString_SYS(NEWMAP, "IPJ_UNITS", s4);
		SetString_SYS(NEWMAP, "IPJ_LOCALDATUM", s5);    

	} 
	else 
	{

      // --- Batch setup. This allows you to use the current database in script mode ---
      
		GetString_SYS(NEWMAP,"SCAN",sSet);
		if (iStrlen_STR(sSet))
		{
			SetString_SYS(NEWMAP, "SCAN", "");	// force reset each time

			if (iStrcmp_STR(sSet,"DATA",STR_CASE_TOLERANT) == 0) 
			{
				if (iRunGX_SYS("rangedb.gx"))
					DisplayMessage_SYS(_("rangedb GX"),_("Failed to calculate range from database."));
			} 
			else if (iStrcmp_STR(sSet,"GRID",STR_CASE_TOLERANT) == 0) 
			{
				SetString_SYS("IMGRANGE","compute_lat_long","1");    
				if (iRunGX_SYS("imgrange.gx"))
					DisplayMessage_SYS(_("imgrange GX"),_("Failed to calculate range from grid."));
			}
			else
				Abort_SYS(_("Valid parameters for \"NEWMAPLL.SCAN\" are \"DATA\" and \"GRID\"."));

			SETUP_FROM_XYRANGE_PARAMETERS
		}


		// --- get range ---

		rMinLon = rGetReal_SYS(NEWMAP,"MIN_LON");
		rMinLat = rGetReal_SYS(NEWMAP,"MIN_LAT");
		rMaxLon = rGetReal_SYS(NEWMAP,"MAX_LON");
		rMaxLat = rGetReal_SYS(NEWMAP,"MAX_LAT");

		if (rMinLon == rDUMMY)
			Abort_SYS(_("Invalid longitude range."));
		else if (rMinLat == rDUMMY)
			Abort_SYS(_("Invalid latitude range."));

		if (rMinLon > rMaxLon) {r = rMinLon; rMinLon = rMaxLon; rMaxLon = r;}
		if (rMinLat > rMaxLat) {r = rMinLat; rMinLat = rMaxLat; rMaxLat = r;}


		// --- get projection ---

		Destroy_IPJ(hIPJ);
		hIPJ = Create_IPJ();
		GetString_SYS(NEWMAP, "IPJ_NAME", s1);
		if (iStrlen_STR(s1) > 0)
		{
			GetString_SYS(NEWMAP, "IPJ_DATUM", s2);
			GetString_SYS(NEWMAP, "IPJ_METHOD", s3);
			GetString_SYS(NEWMAP, "IPJ_UNITS", s4);
			GetString_SYS(NEWMAP, "IPJ_LOCALDATUM", s5);
			SetGXF_IPJ(hIPJ, s1, s2, s3, s4, s5);
		}
		else
		{
			if (iExistFile_SBF(hSBF,"_xyrange.ipj")) {
				hBF = CreateSBF_BF(hSBF,"_xyrange.ipj",BF_READ);
				Destroy_IPJ(hIPJ);
				hIPJ = CreateS_IPJ(hBF);
				DestroyEx_BF(hBF);
			}
		}


		// --- Set up default projection for geographic coordinates ---

		if (iSourceType_IPJ(hIPJ) == IPJ_TYPE_GCS) {
			MakeProjected_IPJ(hIPJ, rMinLon, rMinLat, rMaxLon, rMaxLat);
		}


		// --- Rotate map? ---

		iRot = iGetInt_SYS(NEWMAP,"ROTATE");
		if(iRot!=0) iRot = 1;   // Rotate by default


		// --- Find rotation necessary to make the center of the
		//     map aligned N-S ---

		hPJ = CreateIPJ_PJ((IPJ)0, hIPJ);  // to go from LL to data
		rX1 = 0.5 * (rMinLon + rMaxLon);
		rY1 = rMinLat;
		ConvertXY_PJ(hPJ,rX1,rY1);
		rX2 = 0.5 * (rMinLon + rMaxLon);
		rY2 = rMaxLat;
		ConvertXY_PJ(hPJ,rX2,rY2);

		rRot = 0.0;
		if(iRot)
			rRot = 90.0 - rArcTan2_MATH(rY2-rY1, rX2-rX1)*57.29577951;


		// --- Save original top/bottom positions for warp ---

		SetReal_VV(hVVx1, 0, rX1);
		SetReal_VV(hVVy1, 0, rY1);
		SetReal_VV(hVVx1, 1, rX2);
		SetReal_VV(hVVy1, 1, rY2);


		// --- Create a clipping polygon along the lat-long boundary. ---

		Clear_PLY (hPLY);
		ClipPLY_PJ(hPJ, rMinLon, rMinLat, rMaxLon, rMaxLat, 0.5, hPLY);
		Copy_PLY(hPLYo,hPLY);
		SaveTable_PLY(hPLYo,"_LLMask.ply");


		// --- Rotate the PLY about the center, and get the range in X and Y ---

		rX = 0.5*(rX1 + rX2);
		rY = 0.5*(rY1 + rY2);
		Rotate_PLY(hPLY, rX, rY, rRot);

		rMinX = rMinY = rMaxX = rMaxY = 0.0;   // stop compile warning
		Extent_PLY(hPLY, rMinX, rMinY, rMaxX, rMaxY);


		// --- Save new top/bottom positions for warp ---

		rDist = rSqrt_MATH((rX2-rX1)*(rX2-rX1) + (rY2-rY1)*(rY2-rY1))/2.0;
		rX1 = rX;
		rX2 = rX;
		rY1 = rY - rDist;
		rY2 = rY + rDist;
		SetReal_VV(hVVx2, 0, rX1);
		SetReal_VV(hVVy2, 0, rY1);
		SetReal_VV(hVVx2, 1, rX2);
		SetReal_VV(hVVy2, 1, rY2);

		if(rMinX==rDUMMY) 
			Abort_SYS(_("Unable to find extent of Lat-Long region"));

	}


	// --- get unit factor and scale ---

	rConv = 1.0;                     
	GetUnits_IPJ(hIPJ,rConv,sUnits);
	if (rConv <= 0.0) Abort_SYS(_("Invalid unit conversion factor in UNITS table."));
	rScale = rGetReal_SYS(NEWMAP,"SCALE");


	// --- get template parameters ---

	GetString_SYS(NEWMAP,"TEMPLATE",sTmpl);
	iTmp = iFindKey_LTB(hTMP,sTmpl);
	if (iTmp < 0) {
		Strcpy_STR(sFile,_("Template not found:"));
		Strcat_STR(sFile,sTmpl);
		Abort_SYS(sFile);
	}


	// --- Check the projection ---

	if (iSourceType_IPJ(hIPJ) != IPJ_TYPE_PCS) {
		Abort_SYS(_("This is not a projected coordinate system map"));
	}                    

	GetGXF_IPJ(hIPJ,s1,s2,s3,s4,s5);
	SetString_SYS(NEWMAP,"IPJ_NAME",s1);
	SetString_SYS(NEWMAP,"IPJ_DATUM",s2);
	SetString_SYS(NEWMAP,"IPJ_METHOD",s3);
	SetString_SYS(NEWMAP,"IPJ_UNITS",s4);
	SetString_SYS(NEWMAP,"IPJ_LOCALDATUM",s5);


	// --- layout ---

	GetString_LTB(hTMP,iTmp,iLayoutF,sSet);
	if (iStrStr_STR(sSet, _("portrait"), STR_CASE_TOLERANT) != -1)
		iPort = TRUE;
	else         
		iPort = FALSE;


	// --- exact size ---

	GetString_LTB(hTMP,iTmp,iFixedF,sSet);
	if (iStrStr_STR(sSet, _("fixed"), STR_CASE_TOLERANT) != -1)
		iExact = TRUE;
	else         
		iExact = FALSE;


	// --- margins ---

	rMargXmin = rGetReal_LTB(hTMP,iTmp,iMargin_LeftF);
	rMargXmax = rGetReal_LTB(hTMP,iTmp,iMargin_RightF);
	rMargYmin = rGetReal_LTB(hTMP,iTmp,iMargin_BottomF);
	rMargYmax = rGetReal_LTB(hTMP,iTmp,iMargin_TopF);
	rInside   = rGetReal_LTB(hTMP,iTmp,iMargin_InsideF);


	// --- media string ---

	GetString_LTB(hTMP,iTmp,iMediaF,sSet);
	iMed = iFindKey_LTB(hMED,sSet);
	if (iMed < 0) {
		Strcpy_STR(sFile,_("Media not found:"));
		Strcat_STR(sFile,sSet);
		Abort_SYS(sFile);
	}
	GetString_LTB(hMED,iMed,iSizeXF,sSet);
	Strcpy_STR(sSize,sSet);
	Strcat_STR(sSize,",");
	GetString_LTB(hMED,iMed,iSizeYF,sSet);
	Strcat_STR(sSize,sSet);


	// --- calculate a size for unlimited size ---

	if (iStrMin_STR(sSize) == 1) {
      if ((rScale==rDUMMY) || (rScale <= 0.0)) {
			Abort_SYS(_("Unlimited media size requires a scale."));
		}
		rX = 100.0 * rConv * (rMaxX - rMinX) / rScale + 2.0*rInside + rMargXmax + rMargXmin + 0.25;
		rY = 100.0 * rConv * (rMaxY - rMinY) / rScale + 2.0*rInside + rMargYmax + rMargYmin + 0.25;
		FormatR2_STR(rX, sTemp, 10, 2);
		Strcpy_STR(sSize, sTemp);
		Strcat_STR(sSize, ",");
		FormatR2_STR(rY, sTemp, 10, 2);
		Strcat_STR(sSize, sTemp);                   
	}


	// --- open the map and set up views ---

	GetString_SYS(NEWMAP,"MAP",sMap);
	if (iLoaded_EMAP(sMap)) UnLoad_EMAP(sMap);
	Map = Create_MAP(sMap,MAP_WRITENEW);
	Mapset_MVU(Map,"*Base","*Data",rMinX,rMaxX,rMinY,rMaxY,sSize,iPort,iExact,
		rScale,1.0/rConv,rMargXmin,rMargXmax,rMargYmin,rMargYmax,rInside);



	// --- create the map REG ---

	MapReg = Create_REG(128);
	GetString_LTB(hTMP,iTmp,iTypeF,sSet);
	Set_REG(MapReg,"MAP.STYLE",sSet);


	// --- inside margin ---

	GetString_LTB(hTMP,iTmp,iMargin_InsideF,sSet);
	Set_REG(MapReg,"MAP.MARGIN_INSIDE",sSet);


	// --- up ---

	GetString_LTB(hTMP,iTmp,iUpDirF,sSet);
	Set_REG(MapReg,"MAP.UP_DIRECTION",sSet);
	GetString_LTB(hTMP,iTmp,iUpAngF,sSet);
	Set_REG(MapReg,"MAP.UP_ANGLE",sSet);


	// --- Add Lat,Lon information ---

	SetInt_REG(MapReg,"MAP_LL.CLIP",1);
	SetReal_REG(MapReg,"MAP_LL.MIN_LON",rMinLon);
	SetReal_REG(MapReg,"MAP_LL.MAX_LON",rMaxLon);
	SetReal_REG(MapReg,"MAP_LL.MIN_LAT",rMinLat);
	SetReal_REG(MapReg,"MAP_LL.MAX_LAT",rMaxLat);

	SetReal_SYS("XYRANGE","MIN_LON",rMinLon);
	SetReal_SYS("XYRANGE","MIN_LAT",rMinLat);
	SetReal_SYS("XYRANGE","MAX_LON",rMaxLon);
	SetReal_SYS("XYRANGE","MAX_LAT",rMaxLat);


	// --- put REG in the map ---

	SetREG_MAP(Map,MapReg);


	// --- create an MDF ---

	FileExt_STR(sMap,"mdf",sMdf,FILE_EXT_FORCE);
	MapMDF_MVU(Map,sMdf,"*Data");


	// --- Add a rotational warp to the IPJ ---

	if(iRot)
		AddWarp_IPJ(hIPJ, 2, hVVx2, hVVy2, hVVx1, hVVy1);


	// --- set view projection ---

	View = Create_MVIEW(Map,"*Data",MVIEW_WRITEOLD);
	SetIPJ_MVIEW(View,hIPJ);
	ClearWarp_IPJ(hIPJ);
	SetUserIPJ_MVIEW(View,hIPJ);


	// --- Set the view's clip region to the selected region

	SetClipPLY_MVIEW(View, hPLYo);
	Destroy_MVIEW(View);


	// --- done ---

	Destroy_VV(hVVx1);
	Destroy_VV(hVVx2);
	Destroy_VV(hVVy1);
	Destroy_VV(hVVy2);
	Destroy_PLY(hPLY);
	Destroy_PLY(hPLYo);
	Destroy_SYS(Map);
	Destroy_SYS(MapReg);
	Destroy_SBF(hSBF);


	// --- Display Map ---

	Load_EMAP(sMap);
}
