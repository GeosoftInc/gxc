//*** extends 'class_empty.gxh'

#ifndef HPGU_GXH_DEFINED
#define HPGU_GXH_DEFINED

//*** block Header
// NOTICE: Do not edit anything here, it is generated code
//===========================================================================================================
//
// Class PGU
//
//-----------------------------------------------------------------------------------------------------------
//
// A collection of methods applied to PG objects, including
// fills, trending and 2-D FFT operations.
//
//-----------------------------------------------------------------------------------------------------------



//*** endblock Header

//*** block Editable
// NOTICE: The code generator will not replace the code in this block
//*** endblock Editable

//*** block Generated
// NOTICE: Do not edit anything here, it is generated code


//===========================================================================================================
//
// BLAKEY_TEST Definitions
//
// Types of BLAKEY tests
//
// BLAKEY_TEST_ONESIDE
// 
//
// BLAKEY_TEST_TWOSIDE
// 
//
// BLAKEY_TEST_THREESIDE
// 
//
// BLAKEY_TEST_FOURSIDE
// 
//
//===========================================================================================================


#define BLAKEY_TEST_ONESIDE 1
#define BLAKEY_TEST_TWOSIDE 2
#define BLAKEY_TEST_THREESIDE 3
#define BLAKEY_TEST_FOURSIDE 4


//===========================================================================================================
//
// PGU_CORR Definitions
//
// Correlation (must be synchronized with ST2_CORRELATION)
//
// PGU_CORR_SIMPLE
// Simple correlation
//
// PGU_CORR_PEARSON
// Pearson's correlation (normalized to standard deviations)
//
//===========================================================================================================


#define PGU_CORR_SIMPLE 0
#define PGU_CORR_PEARSON 1


//===========================================================================================================
//
// PGU_DIRECTGRID Definitions
//
// Type of statistic to use on the data points in each cell.
//
// PGU_DIRECTGRID_MINIMUM
// Select the minimum value found in each cell
//
// PGU_DIRECTGRID_MAXIMUM
// Select the maximum value found in each cell
//
// PGU_DIRECTGRID_MEAN
// Select the mean of all values found in each cell
//
// PGU_DIRECTGRID_ITEMS
// The number of valid (non-dummy) items found in each cell
//
//===========================================================================================================


#define PGU_DIRECTGRID_MINIMUM 0
#define PGU_DIRECTGRID_MAXIMUM 1
#define PGU_DIRECTGRID_MEAN 2
#define PGU_DIRECTGRID_ITEMS 3


//===========================================================================================================
//
// PGU_DIRECTION Definitions
//
// Direction
//
// PGU_FORWARD
// Forward direction: Removes mean and standard deviation,
// storing the values in the VVs.
//
// PGU_BACKWARD
// Backward direction: Applies mean and standard deviation
// values in the VVs to the data.
//
//===========================================================================================================


#define PGU_FORWARD 0
#define PGU_BACKWARD 1


//===========================================================================================================
//
// PGU_TRANS Definitions
//
// Transform methods for the columns
//
// PGU_TRANS_NONE
// 
//
// PGU_TRANS_LOG
// 
//
//===========================================================================================================


#define PGU_TRANS_NONE 0
#define PGU_TRANS_LOG 1


//===========================================================================================================
//
// PGU_INTERP_ORDER Definitions
//
// Interpolation direction order
//
// PGU_INTERP_ORDER_XYZ
// 
//
// PGU_INTERP_ORDER_XZY
// 
//
// PGU_INTERP_ORDER_YXZ
// 
//
// PGU_INTERP_ORDER_YZX
// 
//
// PGU_INTERP_ORDER_ZXY
// 
//
// PGU_INTERP_ORDER_ZYX
// 
//
//===========================================================================================================


#define PGU_INTERP_ORDER_XYZ 0
#define PGU_INTERP_ORDER_XZY 1
#define PGU_INTERP_ORDER_YXZ 2
#define PGU_INTERP_ORDER_YZX 3
#define PGU_INTERP_ORDER_ZXY 4
#define PGU_INTERP_ORDER_ZYX 5





//===========================================================================================================
//
// General Functions
//
//===========================================================================================================


  
//-----------------------------------------------------------------------------------------------------------
// Bool_PGU Apply reference file boolean mask to pager
//
// Available 5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void Bool_PGU(PG,       // Pager obj
                          string);  // sRefFil - reference file for boolean mask flag.


  
//-----------------------------------------------------------------------------------------------------------
// Expand_PGU Expand a pager by filling the dummies for expanded edges
//
// Notes      3D pagers are expanded in X,Y direction the number of slices(Z) is unchanged .
//
// Available  5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void Expand_PGU(PG,     // Original pager obj
                            PG,     // Expanded pager obj
                            real,   // % expansion
                            int,    // Option  0 - rectangular, 1 - square
                            int,    // X dimension to expand to (0 for expansion to FFT2D legal dimension)
                            int);   // Y dimension to expand to (0 for expansion to FFT2D legal dimension)


  
//-----------------------------------------------------------------------------------------------------------
// Fill_PGU Replace all dummies in a pager by predict values.
//
// Available 5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void Fill_PGU(PG,       // Pager obj
                          int,      // Roll off weighting option: 1 - linear, 2 - square
                          real,     // dRollBase - the value to roll off to, GS_R8DM for roll off to mean value line by line.
                          int,      // lRollDist - (at unit of cell dist.) for roll-off. 0 for no roll of, -1 for the default: 2 times of min. dummy edge dim.
                          int,      // lMxf - max. filter length.  -1 for no max. entropy. 0 for the default of MIN(minimum dummy edge dim, 32).
                          int,      // lMxp - max. pred. sample 0 for the default of 2*lMxf.
                          real,     // dAmpLmt - limit (abs. value) amplitudes to this level. Amplitudes are limited starting at half this value. <=0.0 for no amp limit.
                          real,     // dEdgeLmt - limit edge (abs. value) amplitudes to this level. <0.0 for no edge limit.
                          int,      // lEdgeWidth - within this dist. (at unit of cell size) for amp. limited. -1 for no edge limit. 0 for the default of minimum dummy edge dim.
                          int,      // iNPass - number of time to pass smooth filter
                          string);  // sRefFil - reference file for smooth filter flag.


  
//-----------------------------------------------------------------------------------------------------------
// FillValue_PGU Set all values in a pager to a single value.
//
// Available     5.0.8
//-----------------------------------------------------------------------------------------------------------

[_licensed] void FillValue_PGU(PG,     // Pager obj
                               real);  // Value to set in pager


  
//-----------------------------------------------------------------------------------------------------------
// FiltSym_PGU Apply 5x5, 7x7 or 9X9 symmetric convolution filter to a PG.
//
// Available   5.1.5
//-----------------------------------------------------------------------------------------------------------

[_licensed] void FiltSym_PGU(PG,       // Pager obj
                             int,      // Number of time to pass smooth filter
                             int,      // Flag to use filter file
                             string,   // File for filter values
                             int,      // Size of filter window, 5/7/9
                             VV);      // Array of 6/10/15 filter coefficients


  
//-----------------------------------------------------------------------------------------------------------
// FiltSym5_PGU Apply 5x5 symmetric convolution filter to a PG.
//
// Available    5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void FiltSym5_PGU(PG,       // Pager obj
                              int,      // Number of time to pass smooth filter
                              int,      // Flag to use filter file
                              string,   // File for filter values
                              VV);      // Array of 6 filter coefficients at position 00, 10, 11, 20, 21, 22. Symmetric filters look like : 22 21 20 21 22 21 11 10 11 21 20 10 00 10 20 21 11 10 11 21 22 21 20 21 22


  
//-----------------------------------------------------------------------------------------------------------
// GridPeak_PGU Pick grid peaks.
//
// Notes        Blakey test limit defines how grid peaks are to be found.
//              For example, with the BLAKEY_TEST_ONESIDE, a grid
//              point will be picked if its grid value is greater than
//              the value of one or more of its four neighouring points.
//
// Available    5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void GridPeak_PGU(string,   // Grid file name
                              int,      // BLAKEY_TEST
                              VV,       // X of found peaks
                              VV,       // Y of found peaks
                              VV);      // Z values of found peaks


  
//-----------------------------------------------------------------------------------------------------------
// IDWGriddingDAT_PGU IDWGriddingDAT_PGU     Inverse-distance weighting gridding method, DAT version.
//
// Notes              See the notes for IDWGriddingDB_PGU.
//
// Available          7.3
//-----------------------------------------------------------------------------------------------------------

[_licensed] void IDWGriddingDAT_PGU(PG,    // Input grid
                                    DAT,   // DAT source
                                    REG);  // Parameters (see above)


  
//-----------------------------------------------------------------------------------------------------------
// IDWGriddingDAT3D_PGU IDWGriddingDAT3D_PGU     Inverse-distance weighting gridding method, DAT version, 3D.
//
// Notes                See the notes for IDWGriddingDB3D_PGU.
//
// Available            8.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void IDWGriddingDAT3D_PGU(PG,    // Input 3D PG
                                      DAT,   // DAT source
                                      REG);  // Parameters (see above)


  
//-----------------------------------------------------------------------------------------------------------
// IDWGriddingDB_PGU IDWGriddingDB_PGU     Inverse-distance weighting gridding method, DB version.
//
// Notes             Grid cells take on the averaged values within a search radius, weighted inversely by distance.
//                   
//                   Weighting can be controlled using the power and slope properties;
//                   
//                   weighting = 1 / (distance^wtpower + 1/slope) where distance is in
//                   units of grid cells (X dimenstion). Default is 0.0,
//                   
//                   If the blanking distance is set, all cells whose center point is not within the blanking distance of
//                   at least one data point are set to dummy.
//                   
//                   REG Parameters:
//                   
//                   X0, Y0, DX, DY: Grid origin, and cell sizes (required)
//                   WT_POWER (default=2), WT_SLOPE (default=1) Weighting function parameters
//                   SEARCH_RADIUS: Distance weighting limit (default = 4 * SQRT(DX*DY))
//                   BLANKING_DISTANCE: Dummy values farther from data than this distance. (default = 4 * SQRT(DX*DY))
//                   LOG: Apply log transform to input data before gridding (0:No (default), 1:Yes)?
//                   LOG_BASE: One of VV_LOG_BASE_10 (default) or VV_LOG_BASE_E
//                   LOG_NEGATIVE: One of VV_LOG_NEGATIVE_NO (default) or VV_LOG_NEGATIVE_YES
//
// Available         7.3
//-----------------------------------------------------------------------------------------------------------

[_licensed] void IDWGriddingDB_PGU(PG,        // Input grid
                                   DB,        // Database
                                   DB_SYMB,   // X Channel [READONLY]
                                   DB_SYMB,   // Y Channel [READONLY]
                                   DB_SYMB,   // Data Channel [READONLY]
                                   REG);      // Parameters (see above)


  
//-----------------------------------------------------------------------------------------------------------
// IDWGriddingDB3D_PGU IDWGriddingDB3D_PGU     Inverse-distance weighting gridding method, DB version, 3D.
//
// Notes               3D cells take on the averaged values within a search radius, weighted inversely by distance.
//                     
//                     Weighting can be controlled using the power and slope properties;
//                     
//                     weighting = 1 / (distance^wtpower + 1/slope) where distance is in
//                     units of grid cells (X dimenstion). Default is 0.0,
//                     
//                     If the blanking distance is set, all cells whose center point is not within the blanking distance of
//                     at least one data point are set to dummy.
//                     
//                     REG Parameters:
//                     
//                     X0, Y0, Z0, DX, DY, DZ: Grid origin, and cell sizes (required)
//                     WT_POWER (default=2), WT_SLOPE (default=1) Weighting function parameters
//                     SEARCH_RADIUS: Distance weighting limit (default = 4 * CUBE_ROOT(DX*DY*DZ))
//                     BLANKING_DISTANCE: Dummy values farther from data than this distance. (default = 4 * CUBE_ROOT(DX*DY*DZ))
//                     LOG: Apply log transform to input data before gridding (0:No (default), 1:Yes)?
//                     LOG_BASE: One of VV_LOG_BASE_10 (default) or VV_LOG_BASE_E
//                     LOG_NEGATIVE: One of VV_LOG_NEGATIVE_NO (default) or VV_LOG_NEGATIVE_YES
//
// Available           8.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void IDWGriddingDB3D_PGU(PG,        // Input 3D PG
                                     DB,        // Database
                                     DB_SYMB,   // X Channel [READONLY]
                                     DB_SYMB,   // Y Channel [READONLY]
                                     DB_SYMB,   // Z Channel [READONLY]
                                     DB_SYMB,   // Data Channel [READONLY]
                                     REG);      // Parameters (see above)


  
//-----------------------------------------------------------------------------------------------------------
// IDWGriddingVV_PGU IDWGriddingVV_PGU     Inverse-distance weighting gridding method, VV version.
//
// Notes             See the notes for IDWGriddingDB_PGU.
//
// Available         7.3
//-----------------------------------------------------------------------------------------------------------

[_licensed] void IDWGriddingVV_PGU(PG,    // Input grid
                                   VV,    // X locations
                                   VV,    // Y locations
                                   VV,    // Data values to grid
                                   REG);  // Parameters (see above)


  
//-----------------------------------------------------------------------------------------------------------
// NumericToThematic_PGU NumericToThematic_PGU    Set index values in a pager based on a numeric pager with translation VV.
//                       
//                       Returns			  Nothing
//
// Notes                 The values in the input data VV represent the center-of-range
//                       values of unique properties with indices 0 to N-1, where N
//                       is the number of items in the input VV.
//                       
//                       This VV is sorted from smallest to largest, and each value in
//                       in the input numeric PG is tested to see into which range it goes.
//                       The closest range value for each item is used, so the half-way point
//                       is the dividing point. The top and bottom-most range widths are determined
//                       by the "inside half-width" to the nearest range.
//                       
//                       The INDEX of the closest range is then inserted into the output PG, so
//                       it can be used in a thematic voxel (for instance).
//
// Available             7.3
//-----------------------------------------------------------------------------------------------------------

[_licensed] void NumericToThematic_PGU(PG,   // Input numeric PG
                                       VV,   // Translation VV (see notes above)
                                       PG);  // Output thematic PG


  
//-----------------------------------------------------------------------------------------------------------
// Peakedness_PGU Find all peaks in peakedneess grid pager
//
// Available      5.0.8
//-----------------------------------------------------------------------------------------------------------

[_licensed] void Peakedness_PGU(string,   // Grid file name
                                int,      // Cutoff limit for finding peaks
                                VV,       // X of found peaks
                                VV,       // Y of found peaks
                                VV);      // Z values of found peaks


  
//-----------------------------------------------------------------------------------------------------------
// PeakednessGrid_PGU Create peakedneess grid from input grid.
//
// Notes              This function creates a peakedneess grid from input grid.
//                    Radius, is the maximum radius at which the value of the parent pixel is compared to
//                    the value of surrounding pixels.
//                    percent_lesser, is used to indicate the percentage of pixels at each radii smaller than
//                    or equal to Radius that must have value lower than the parent pixel in order to call
//                    that radius true or equal to 1.
//                    Description:  For each pixel in the grid a series of radii are evaluated from 1 to Radius.
//                    If the percentage of pixels for a given radius is less than percent_lesser the parent pixel
//                    receives an additional 1.
//                    For examples if the Radius is set to 5 and the percent_lesser is set to 70%.
//                    And radius 1 = 90%, radius 2 = 85%, radius 3 = 75%, radius 4 = 70% and radius 5 = 65%
//                    then the parent pixel would receive 1+1+1+1+0 = 4.
//                    Use:  This function is useful in isolating the anomaly peaks in data that has a large
//                    value range for anomalies. For example the 1 mV anomaly could quite possibly have
//                    the same representation as the 100 mV anomaly using this function.
//
// Available          5.0.8
//-----------------------------------------------------------------------------------------------------------

[_licensed] void PeakednessGrid_PGU(string,   // Input grid file name
                                    string,   // Output grid (peakedness) file name
                                    int,      // Radius
                                    real);    // Percent Lesser value (see notes)


  
//-----------------------------------------------------------------------------------------------------------
// RefFile_PGU Create a reference file (boolean mask flag) from pager.
//
// Notes       A reference file is a binary file with the following format:
//             
//             The first 8 bytes are the pager dimensions NX and NY as longs.
//             The remaining bits, one bit per pager cell - (NX * NY)/8 bytes
//             are zero where the pager is dummy, and 1 where the pager is defined.
//             
//             The reference file is used in various operations where it is
//             necessary to mask some output to the original defined cells.
//
// Available   5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void RefFile_PGU(PG,       // PG object
                             string);  // Reference file name


  
//-----------------------------------------------------------------------------------------------------------
// SaveFile_PGU Writes a PG to an image file.
//
// Notes        The trend object and projection are optional.
//
// Available    5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void SaveFile_PGU(PG,       // Input PG object
                              real,     // X origin
                              real,     // Y origin
                              real,     // DX
                              real,     // DY
                              real,     // Rotation angle
                              TR,       // Trend information or NULL
                              IPJ,      // Projection or NULL
                              string);  // Output file name


  
//-----------------------------------------------------------------------------------------------------------
// ThematicToNumeric_PGU Set numeric values in a pager based on an index pager with translation VV.
//                       
//                       Returns			  Nothing
//
// Notes                 The items in the input data VV are inserted into
//                       the output PG using the indices in the index PG.
//                       
//                       This function is useful when converting a thematic voxel, which is
//                       type GS_LONG and contains indices into its own internal TPAT
//                       object, and you provide a numeric mapping VV, calculated using
//                       SetupTranslateToNumericVV_TPAT.
//
// Available             7.3
//-----------------------------------------------------------------------------------------------------------

[_licensed] void ThematicToNumeric_PGU(PG,   // Input Index PG
                                       VV,   // Translation VV
                                       PG);  // Output Data PG


  
//-----------------------------------------------------------------------------------------------------------
// Trend_PGU Trend remove or replace back in pager
//
// Available 5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void Trend_PGU(PG,     // Original pager obj
                           PG,     // Trended pager obj
                           TR,     // Trend obj
                           int,    // Option  0 - calculate, 1 - given in TR, 2 - replace back from TR
                           int,    // Trend base on: 0 - all points, 1 - edge points
                           real,   // Trend origin  rXo,
                           real,   // Trend origin  rYo,
                           real,   // Increment in X direction  rDx,
                           real);  // Increment in Y direction  rDy



//===========================================================================================================
//
// Math Operations Functions
//
//===========================================================================================================


  
//-----------------------------------------------------------------------------------------------------------
// AddScalar_PGU Add a scalar value to a pager
//
// Notes         Only available for FLOAT or DOUBLE pagers
//
// Available     7.1
//-----------------------------------------------------------------------------------------------------------

[_licensed] void AddScalar_PGU(PG,     // Pager
                               real);  // Scalar Value


  
//-----------------------------------------------------------------------------------------------------------
// MultiplyScalar_PGU Multiply a scalar value and a pager
//
// Notes              Only available for FLOAT or DOUBLE pagers
//
// Available          7.1
//-----------------------------------------------------------------------------------------------------------

[_licensed] void MultiplyScalar_PGU(PG,     // Pager
                                    real);  // Scalar Value



//===========================================================================================================
//
// Matrix Operation Functions
//
//===========================================================================================================


  
//-----------------------------------------------------------------------------------------------------------
// CorrelationMatrix_PGU Find the correlations between columns in a matrix
//
// Notes                 The input matrix is M rows by N columns. The returned matrix
//                       is a symmetric N by N matrix whose elements are the normalized
//                       dot products of the columns of the input matrix with themselves.
//                       The elements take on values from 0 (orthogonal) to 1 (parallel).
//
// Available             5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void CorrelationMatrix_PGU(PG,   // Input matrix
                                       PG);  // Returned correlation matrix


  
//-----------------------------------------------------------------------------------------------------------
// CorrelationMatrix2_PGU Same as CorrelationMatrix_PGU, but select correlation type.
//
// Available              5.1.8
//-----------------------------------------------------------------------------------------------------------

[_licensed] void CorrelationMatrix2_PGU(PG,    // Input matrix
                                        int,   // PGU_CORR
                                        PG);   // Returned correlation matrix


  
//-----------------------------------------------------------------------------------------------------------
// InvertMatrix_PGU Inverts a square matrix using LU decomp. and back-substitution
//
// Notes            This is an "in-place" operation, and set up so that the input and
//                  output pagers may be the same handle. (If they are different, the
//                  input pager remains unchanged).
//                  Pagers and VVs must be type GS_DOUBLE.
//
// Available        5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void InvertMatrix_PGU(PG,   // Input matrix
                                  PG);  // Output inverted matrix (can be same as input).


  
//-----------------------------------------------------------------------------------------------------------
// Jacobi_PGU Find eigenvalues, eigenvectors of a real symmetric matrix.
//
// Notes      The number of rows must equal the number of columns.
//            Eienvalues, vectors are sorted in descending order.
//
// Available  5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void Jacobi_PGU(PG,   // Input Pager
                            VV,   // Eigenvalues (returned)
                            PG);  // Eigenvectors (returned)


  
//-----------------------------------------------------------------------------------------------------------
// LUBackSub_PGU Solve a linear system using LU decomposition and back-substitution.
//
// Notes         Solves the system Ax = b for a given b, using the LU decomposition
//               of the matrix a
//               The LU decomposition and the permutation vector are obtained
//               from LUBackSub_PGU.
//               Pagers and VVs must be type GS_DOUBLE except for the permutation vector,
//               which should be INT
//
// Available     5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void LUBackSub_PGU(PG,   // LU decomposition of A
                               VV,   // Permutation vector (type INT)
                               VV,   // Right hand side vector B (input)
                               VV);  // Solution vector (output)


  
//-----------------------------------------------------------------------------------------------------------
// LUDecomp_PGU Perform an LU decomposition on a square pager.
//
// Notes        The L and U matrix are both contained in the returned pager; The
//              "L" matrix is composed of the sub-diagonal elements of the output
//              pager, as well as "1" values on the diagonal. The "U" matrix is
//              composed of the diagonal elements (sub-diagonal elements set to 0).
//              This is an "in-place" operation, and set up so that the input and
//              output pagers may be the same handle. (If they are different, the
//              input pager remains unchanged).
//              The LU decomposition, and the permutation vector are used for
//              LUBackSub_PGU.
//              Pagers must be type GS_DOUBLE and the permutation vector type INT
//
// Available    5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void LUDecomp_PGU(PG,   // Input
                              PG,   // LU decomposition (may be same pager as input)
                              VV);  // Permutation vector (type INT)


  
//-----------------------------------------------------------------------------------------------------------
// MatrixMult_PGU Multiply two pagers as if they were matrices.
//
// Notes          The matrices must be correctly dimensioned, taking into
//                account whether transposition should occur before
//                multiplication. The input matrices are not altered on output (even
//                if transposition is requested).
//                Assertions if: Matrices are not expected sizes
//                Dummies are treated as 0 values.
//
// Available      5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void MatrixMult_PGU(PG,    // Matrix U
                                int,   // TRUE (1) if U should be transposed before multiplication
                                PG,    // Matrix V
                                int,   // TRUE (1) if V should be transposed before multiplication
                                PG);   // Returned matrix U*V


  
//-----------------------------------------------------------------------------------------------------------
// MatrixVectorMult_PGU Multiply a VV by a pager like a matrix*vector multiply.
//
// Notes                The matrix is input as an M rows (data) by N columns (variables) PG.
//                      The vector must be of length N. The output VV is set to length M.
//                      The PG and VVs must be type GS_DOUBLE.
//                      
//                      Terminates if: 
//                      
//                           Matrices, VV are not expected sizes (taken from U)
//                           PGs are not GS_DOUBLE.
//                      
//                      Dummies are treated as 0 values.
//
// Available            5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void MatrixVectorMult_PGU(PG,   // Matrix U
                                      VV,   // Vector x
                                      VV);  // Returned vector U*x


  
//-----------------------------------------------------------------------------------------------------------
// SVDecompose_PGU Do a singular value decomposition on a matrix stored as a PG
//
// Notes           The matrix is input as an N rows (data) by M columns (variables) PG.
//                 On return, the matrix is decomposed to A = U * W * Vt. If M<N, then an error will 
//                 be registered. In this case, augment the "A" PG with rows of zero values.
//                 
//                 The input matrices must be A[M,N], U[M.N] and V[N,N]. The length of the W VV
//                 is set by sSVD_PGU to N.
//                 
//                 The Pagers must be type GS_DOUBLE.
//                 
//                 Terminates if: 
//                 
//                      U is not M by N. (Taken from size of A)
//                      V is not N by N. (Taken from #columns in A).
//                      PGs, VV are not GS_DOUBLE
//
// Available       5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void SVDecompose_PGU(PG,   // Input A matrix, M data (rows), N variables (columns)
                                 PG,   // The returned U Matrix
                                 VV,   // Returned weights (W)
                                 PG);  // Returned V matrix


  
//-----------------------------------------------------------------------------------------------------------
// SVRecompose_PGU Reconstitute the original matrix from an SVD.
//
// Notes           The matrix is input as an N rows (data) by M columns (variables) PG.
//                 On return, the matrix is decomposed to A = U * W * Vt.
//                 If M<N, then an error will be registered. In this case, augment the
//                 "A" PG with rows of zero values.
//                 The input matrices must be A[M,N], U[M.N] and V[N,N]. The length of the W VV
//                 is set by sSVDecompose_PGU to N.
//                 The Pagers must be type GS_DOUBLE.
//                 
//                 Terminates if: 
//                 
//                      U is not M by N. (Taken from size of A)
//                      V is not N by N. (Taken from #columns in A).
//                      PGs, VV are not GS_DOUBLE.
//                 
//                 Dummies are treated as 0 values.
//
// Available       5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void SVRecompose_PGU(PG,     // U matrix
                                 VV,     // Weights (W)
                                 PG,     // V matrix
                                 real,   // Minimum weight to use (Dummy for all)
                                 PG);    // A matrix (returned)



//===========================================================================================================
//
// Principal Component Analysis Functions
//
//===========================================================================================================


  
//-----------------------------------------------------------------------------------------------------------
// PCCommunality_PGU Determines principal component communalities.
//
// Notes             Calculate communalities (sums of the squares of the column
//                   values in each row)
//                   Pagers and VVs must be type GS_DOUBLE.
//
// Available         5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void PCCommunality_PGU(PG,   // Input pager of the principal components
                                   VV);  // Returned communality values


  
//-----------------------------------------------------------------------------------------------------------
// PCLoadings_PGU Compute the principal component loadings from the standardized data.
//
// Notes          Works on columns of the PG.
//                Calculates the correlation matrix from the columns of the
//                standardized data, then computes the eigen values and eigenvectors
//                of the correlation matrix. The loadings are the eigenvectors, ordered
//                by descending eigenvalues, scaled by the square root of the
//                eigenvalues. The returned pager must be sized the same as the
//                input pager.
//                Correlations are performed using "PGU_CORR_SIMPLE", so if you want
//                Pearson correlations, or wish to use a modified correlation matrix,
//                use PCLoadings2_PGU and input the correlation matrix directly.
//
// Available      5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void PCLoadings_PGU(PG,   // Standardized data matrix (M by N)
                                PG);  // Principal component loadings (N by N)


  
//-----------------------------------------------------------------------------------------------------------
// PCLoadings2_PGU Same as PCLoading_PGU, but input correlation matrix.
//
// Notes           See PCLoadings_PGU.
//
// Available       5.1.8
//-----------------------------------------------------------------------------------------------------------

[_licensed] void PCLoadings2_PGU(PG,   // Correllation matrix (N by N)
                                 PG);  // Principal component loadings (N by N)


  
//-----------------------------------------------------------------------------------------------------------
// PCScores_PGU Compute the principal component scores from the standardized data.
//
// Notes        t  -1
//              Forms the product X Ap (Ap Ap),  where X is the
//              standardized data matrix, and Ap is the matrix of
//              principal component loadings (see PCLoadings_PGU).
//              The loadings must be input, and can be calculated by calling
//              PCLoadings_PGU.
//              Pagers and VVs must be type GS_DOUBLE.
//
// Available    5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void PCScores_PGU(PG,   // Standardized data matrix  (M by N)
                              PG,   // Principal component loadings (input) (N by L, L<=N)
                              PG);  // Principal component scores (returned) (M by L, L<=N)


  
//-----------------------------------------------------------------------------------------------------------
// PCStandardize_PGU Remove/Replace mean and standard deviation
//
// Notes             Works on columns of the PG.
//
// Available         5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void PCStandardize_PGU(PG,    // Matrix to standardize
                                   VV,    // Means
                                   VV,    // Standard deviations
                                   int);  // PGU_DIRECTION


  
//-----------------------------------------------------------------------------------------------------------
// PCStandardize2_PGU Remove/Replace mean and standard deviation, subset values.
//
// Notes              Like PCStandardize_PGU, except that not all the values are
//                    included in the calculation of the means and standard
//                    deviations. The inclusion is controlled by a mask VV,
//                    The rows where the mask is dummy are not included
//                    in the calculation, but ALL the values are standardized.
//
// Available          5.1.8
//-----------------------------------------------------------------------------------------------------------

[_licensed] void PCStandardize2_PGU(PG,    // Matrix to standardize
                                    VV,    // Mask VV for data selection (forward only)
                                    VV,    // Means
                                    VV,    // Standard deviations
                                    int);  // Forward or reverse


  
//-----------------------------------------------------------------------------------------------------------
// PCTransform_PGU Transform/De-transform data.
//
// Notes           Works on columns of the PG.
//                 Forward direction: Applies the selected transform to the data.
//                 Backward direction: Applies the inverse transform to the data.
//                 The detection limits are input with a VV. In the forward
//                 transform, data values less than the detection limit are set
//                 to the limit.
//                 The factor limits are input with a VV. In the forward
//                 transform, data values greater than the maximum values are set
//                 to the maximum.
//
// Available       5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void PCTransform_PGU(PG,    // Matrix to transform
                                 VV,    // Detection limits for the columns
                                 VV,    // Maximum values for the columns
                                 VV,    // PGU_TRANS
                                 int);  // PGU_DIRECTION


  
//-----------------------------------------------------------------------------------------------------------
// PCVarimax_PGU Perform the Kaiser Varimax transformation on pr. comp. loadings
//
// Notes         Rotates the principal components using the Kaiser's varimax
//               scheme to move move each factor axis to positions so that
//               projections from each variable on the factor axes are either
//               near the extremities or near the origin.
//               Pagers must be type GS_DOUBLE.
//
// Available     5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void PCVarimax_PGU(PG,   // Principal component loadings (input) (N by M, M<=N)
                               PG);  // Rotated principal component loadings (returned) (N by L, L<=M)



//===========================================================================================================
//
// Specialized Operations Functions
//
//===========================================================================================================


  
//-----------------------------------------------------------------------------------------------------------
// rMaximumTerrainSteepness_PGU Compute the Maximum Steepness of a topography Pager
//
// Returns                      Maximum Terrain Steepness Computation.
//
// Notes                        Calculates forward-looking slopes SX and SY in the X and Y directions
//                              using pager locations (ix, iy), (ix+size, iy), (ix, iy+isize)
//                              and returns SX*SX + SY*SY.
//                              The values in the last "size" rows and columns are not
//                              processed.
//                              The wrapper was created for testing and development purposes.
//
// Available                    7.1
//-----------------------------------------------------------------------------------------------------------

[_licensed] real rMaximumTerrainSteepness_PGU(PG,    // Topography Pager
                                              int);  // Annular Size



//===========================================================================================================
//
// Deprecated Functions
//
//===========================================================================================================


  
//-----------------------------------------------------------------------------------------------------------
// DirectGrid_PGU Direct-gridding method.
//
// Notes          Grid cells take on the averaged values inside their bounds.
//                
//                Weighting can be controlled using the power and slope properties;
//                
//                weighting = 1 / (distance^wtpower + 1/slope) where distance is in
//                units of grid cells (X dimenstion). Default is 0.0,
//
// Available      7.2
//-----------------------------------------------------------------------------------------------------------

[_licensed] void DirectGrid_PGU(PG,     // Input grid
                                real,   // X origin of grid
                                real,   // Y origin of grid
                                real,   // X cell size
                                real,   // Y cell size
                                real,   // Rotation angle (degrees CCW).
                                VV,     // X locations of values
                                VV,     // Y locations of values
                                VV,     // Z values to grid
                                real,   // Power weighting for averaging (set to 0 for straight average)
                                real);  // Slope weighting for averaging (set to 0 for pure power-law weighting)


  
//-----------------------------------------------------------------------------------------------------------
// FFT2Filter_PGU Carry out a fourier transform filter on a pager object
//
// Available      5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void FFT2Filter_PGU(PG,       // Pager obj
                                string,   // sConFil - FFT filter control file
                                TR,       // TR obj
                                real,     // rDx - X increment
                                real,     // rDy - Y increment
                                real);    // rRot- Rotation degree


  
//-----------------------------------------------------------------------------------------------------------
// FFT2Trans_PGU Carry out a fourier transform on a pager object
//
// Available     5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void FFT2Trans_PGU(PG,    // Pager obj
                               int);  // Option: 0 - forward transform, 1 - invers transform


  
//-----------------------------------------------------------------------------------------------------------
// DirectGriddingDB_PGU Direct-gridding method, DB version.
//
// Notes                Grid cells take on the specified statistic of the values inside the
//                      cell area. Grid cells containing no data values are set to dummy.
//
// Available            7.3
//-----------------------------------------------------------------------------------------------------------

[_licensed] void DirectGriddingDB_PGU(PG,        // Input grid
                                      real,      // X origin of grid
                                      real,      // Y origin of grid
                                      real,      // X cell size
                                      real,      // Y cell size
                                      real,      // Rotation angle (degrees CCW).
                                      DB,        // Database
                                      DB_SYMB,   // X Channel [READONLY]
                                      DB_SYMB,   // Y Channel [READONLY]
                                      DB_SYMB,   // Data Channel [READONLY]
                                      int);      // PGU_DIRECTGRID


  
//-----------------------------------------------------------------------------------------------------------
// DirectGriddingDB2_PGU Direct-gridding method, DB version.
//
// Notes                 Grid cells take on the specified statistic of the values inside the
//                       cell area. Grid cells containing no data values are set to dummy.
//
// Available             2023.1
//-----------------------------------------------------------------------------------------------------------

[_licensed] void DirectGriddingDB2_PGU(PG,        // Input grid
                                       real,      // X origin of grid
                                       real,      // Y origin of grid
                                       real,      // X extent of grid
                                       real,      // Y extent of grid
                                       real,      // X cell size
                                       real,      // Y cell size
                                       real,      // Rotation angle (degrees CCW).
                                       DB,        // Database
                                       DB_SYMB,   // X Channel [READONLY]
                                       DB_SYMB,   // Y Channel [READONLY]
                                       DB_SYMB,   // Data Channel [READONLY]
                                       int);      // PGU_DIRECTGRID


  
//-----------------------------------------------------------------------------------------------------------
// DirectGriddingDB3D_PGU Direct-gridding method, DB version, 3D.
//
// Notes                  3D grid cells take on the specified statistic of the values inside the
//                        cell area. Grid cells containing no data values are set to dummy.
//
// Available              8.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void DirectGriddingDB3D_PGU(PG,        // Input 3D PG
                                        real,      // X origin of 3D grid
                                        real,      // Y origin of 3D grid
                                        real,      // Z origin of 3D grid
                                        real,      // X cell size
                                        real,      // Y cell size
                                        real,      // Z cell size
                                        real,      // Rotation angle (degrees CCW, vertical axis only).
                                        DB,        // Database
                                        DB_SYMB,   // X Channel [READONLY]
                                        DB_SYMB,   // Y Channel [READONLY]
                                        DB_SYMB,   // Z Channel [READONLY]
                                        DB_SYMB,   // Data Channel [READONLY]
                                        int);      // PGU_DIRECTGRID


  
//-----------------------------------------------------------------------------------------------------------
// DirectGriddingVV_PGU Direct-gridding method, VV version.
//
// Notes                Grid cells take on the specified statistic of the values inside the
//                      cell area. Grid cells containing no data values are set to dummy.
//
// Available            7.3
//-----------------------------------------------------------------------------------------------------------

[_licensed] void DirectGriddingVV_PGU(PG,     // Input grid
                                      real,   // X origin of grid
                                      real,   // Y origin of grid
                                      real,   // X cell size
                                      real,   // Y cell size
                                      real,   // Rotation angle (degrees CCW).
                                      VV,     // X locations of values
                                      VV,     // Y locations of values
                                      VV,     // Z values to grid
                                      int);   // PGU_DIRECTGRID





//*** endblock Generated


#endif
