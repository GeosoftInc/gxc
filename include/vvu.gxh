//*** extends 'class_empty.gxh'

#ifndef HVVU_GXH_DEFINED
#define HVVU_GXH_DEFINED

//*** block Header
// NOTICE: Do not edit anything here, it is generated code
//===========================================================================================================
//
// Class VVU
//
//-----------------------------------------------------------------------------------------------------------
//
// These methods are not a class. Utility methods perform
// various operations on VV objects, including pruning,
// splining, clipping and filtering.
//
//-----------------------------------------------------------------------------------------------------------



//*** endblock Header

//*** block Editable
// NOTICE: The code generator will not replace the code in this block
//*** endblock Editable

//*** block Generated
// NOTICE: Do not edit anything here, it is generated code


//===========================================================================================================
//
// QC_CRITERION Definitions
//
// Criterion
//
// QC_CRITERION_1
// 
//
// QC_CRITERION_2
// 
//
// QC_CRITERION_12
// 
//
//===========================================================================================================


#define QC_CRITERION_1 0
#define QC_CRITERION_2 1
#define QC_CRITERION_12 2


//===========================================================================================================
//
// TEM_ARRAY Definitions
//
// Array Type
//
// TEM_ARRAY_VERTICALSOUNDING
// 
//
// TEM_ARRAY_PROFILING
// 
//
// TEM_ARRAY_BOREHOLE
// 
//
//===========================================================================================================


#define TEM_ARRAY_VERTICALSOUNDING 0
#define TEM_ARRAY_PROFILING 1
#define TEM_ARRAY_BOREHOLE 2


//===========================================================================================================
//
// VV_DUP Definitions
//
// Duplicate handling mode
//
// VV_DUP_AVERAGE
// Average numeric values (for strings, same as VV_DUP_1)
//
// VV_DUP_1
// Use first value of the pair
//
// VV_DUP_2
// Use second value of the pair
//
// VV_DUP_DUMMY
// Set to dummy
//
// VV_DUP_SAMPLE
// Set to "3" (cannot use with string data VV)
//
//===========================================================================================================


#define VV_DUP_AVERAGE 0
#define VV_DUP_1 1
#define VV_DUP_2 2
#define VV_DUP_DUMMY 3
#define VV_DUP_SAMPLE 4


//===========================================================================================================
//
// VV_XYDUP Definitions
//
// Sample handling
//
// VV_XYDUP_AVERAGE
// 
//
// VV_XYDUP_SUM
// 
//
//===========================================================================================================


#define VV_XYDUP_AVERAGE 0
#define VV_XYDUP_SUM 1


//===========================================================================================================
//
// VVU_CASE Definitions
//
// String case handling
//
// VVU_CASE_TOLERANT
// 
//
// VVU_CASE_SENSITIVE
// 
//
//===========================================================================================================


#define VVU_CASE_TOLERANT 0
#define VVU_CASE_SENSITIVE 1


//===========================================================================================================
//
// VVU_CLIP Definitions
//
// Type of clipping
//
// VVU_CLIP_DUMMY
// Clip replaces clipped values with a dummy.
//
// VVU_CLIP_LIMIT
// Clip replaces clipped values with the limit.
//
//===========================================================================================================


#define VVU_CLIP_DUMMY 0
#define VVU_CLIP_LIMIT 1


//===========================================================================================================
//
// VVU_DUMMYREPEAT Definitions
//
// How to deal with repeats
//
// VVU_DUMMYREPEAT_FIRST
// Dummies all but first point.
//
// VVU_DUMMYREPEAT_LAST
// Dummies all but last point.
//
// VVU_DUMMYREPEAT_MIDDLE
// Dummies all but middle point.
//
//===========================================================================================================


#define VVU_DUMMYREPEAT_FIRST 0
#define VVU_DUMMYREPEAT_LAST 1
#define VVU_DUMMYREPEAT_MIDDLE 2


//===========================================================================================================
//
// VVU_INTERP Definitions
//
// Interpolation method to use
//
// VVU_INTERP_NEAREST
// 
//
// VVU_INTERP_LINEAR
// 
//
// VVU_INTERP_CUBIC
// 
//
// VVU_INTERP_AKIMA
// 
//
// VVU_INTERP_PREDICT
// 
//
//===========================================================================================================


#define VVU_INTERP_NEAREST 1
#define VVU_INTERP_LINEAR 2
#define VVU_INTERP_CUBIC 3
#define VVU_INTERP_AKIMA 4
#define VVU_INTERP_PREDICT 5


//===========================================================================================================
//
// VVU_INTERP_EDGE Definitions
//
// Interpolation method to use on edges
//
// VVU_INTERP_EDGE_NONE
// 
//
// VVU_INTERP_EDGE_SAME
// 
//
// VVU_INTERP_EDGE_NEAREST
// 
//
// VVU_INTERP_EDGE_LINEAR
// 
//
//===========================================================================================================


#define VVU_INTERP_EDGE_NONE 0
#define VVU_INTERP_EDGE_SAME 1
#define VVU_INTERP_EDGE_NEAREST 2
#define VVU_INTERP_EDGE_LINEAR 3


//===========================================================================================================
//
// VVU_LINE Definitions
//
// Line Types
//
// LINE_2_POINTS
// 
//
// LINE_POINT_AZIMUTH
// 
//
//===========================================================================================================


#define LINE_2_POINTS 0
#define LINE_POINT_AZIMUTH 1


//===========================================================================================================
//
// VVU_MASK Definitions
//
// Type of clipping
//
// VVU_MASK_INSIDE
// Mask VV is set to dummy at locations inside the PLY.
//
// VVU_MASK_OUTSIDE
// Mask VV is set to dummy at locations outside the PLY.
//
//===========================================================================================================


#define VVU_MASK_INSIDE 0
#define VVU_MASK_OUTSIDE 1


//===========================================================================================================
//
// VVU_MATCH Definitions
//
// Matching style
//
// VVU_MATCH_FULL_STRINGS
// Entire string
//
// VVU_MATCH_INPUT_LENGTH
// Match the first part of a string.
//
//===========================================================================================================


#define VVU_MATCH_FULL_STRINGS 0
#define VVU_MATCH_INPUT_LENGTH 1


//===========================================================================================================
//
// VVU_MODE Definitions
//
// Statistic to select
//
// VVU_MODE_MEAN
// 
//
// VVU_MODE_MEDIAN
// 
//
// VVU_MODE_MAXIMUM
// 
//
// VVU_MODE_MINIMUM
// 
//
//===========================================================================================================


#define VVU_MODE_MEAN 0
#define VVU_MODE_MEDIAN 1
#define VVU_MODE_MAXIMUM 2
#define VVU_MODE_MINIMUM 3


//===========================================================================================================
//
// VVU_OFFSET Definitions
//
// Heading
//
// VVU_OFFSET_FORWARD
// 
//
// VVU_OFFSET_BACKWARD
// 
//
// VVU_OFFSET_RIGHT
// 
//
// VVU_OFFSET_LEFT
// 
//
//===========================================================================================================


#define VVU_OFFSET_FORWARD 0
#define VVU_OFFSET_BACKWARD 1
#define VVU_OFFSET_RIGHT 2
#define VVU_OFFSET_LEFT 3


//===========================================================================================================
//
// VVU_PRUNE Definitions
//
// Prune options
//
// VVU_PRUNE_DUMMY
// 0
//
// VVU_PRUNE_VALID
// 1
//
//===========================================================================================================


#define VVU_PRUNE_DUMMY 0
#define VVU_PRUNE_VALID 1


//===========================================================================================================
//
// VVU_SPL Definitions
//
// Spline types
//
// VVU_SPL_LINEAR
// 
//
// VVU_SPL_CUBIC
// 
//
// VVU_SPL_AKIMA
// 
//
// VVU_SPL_NEAREST
// 
//
//===========================================================================================================


#define VVU_SPL_LINEAR 0
#define VVU_SPL_CUBIC 1
#define VVU_SPL_AKIMA 2
#define VVU_SPL_NEAREST 3


//===========================================================================================================
//
// VVU_SRCHREPL_CASE Definitions
//
// Search and Replace handling of string case
//
// VVU_SRCHREPL_CASE_TOLERANT
// 
//
// VVU_SRCHREPL_CASE_SENSITIVE
// 
//
//===========================================================================================================


#define VVU_SRCHREPL_CASE_TOLERANT 0
#define VVU_SRCHREPL_CASE_SENSITIVE 1





//===========================================================================================================
//
// Miscellaneous Functions
//
//===========================================================================================================


  
//-----------------------------------------------------------------------------------------------------------
// AverageRepeat_VVU Average repeat values.
//
// Notes             Repeated values in the reference VV will be averaged
//                   in the data VV.  The first value in the data VV will be set to the
//                   average and subsequent data VV values will be dummied out.
//                   Data is processed only to the minimum length of the
//                   input VV lengths.
//
// See also          RemoveDummy_VVU
//
// Available         5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void AverageRepeat_VVU(VV,   // Reference VV
                                   VV);  // Data VV to average


  
//-----------------------------------------------------------------------------------------------------------
// AverageRepeatEx_VVU Average repeat values.
//
// Notes               Repeated values in the reference VV will be set to the mean, median, minimum or maximum value
//                     in the data VV.  For minimum and maximum, the index in the data VV containing the minimum or maximum value
//                     is retained, and the other repeated values are dummied out. For mean and median, the first value in the 
//                     data VV will be reset and subsequent data VV values will be dummied out.
//                     Data is processed only to the minimum length of the
//                     input VV lengths.
//
// See also            RemoveDummy_VVU
//
// Available           8.0.1
//-----------------------------------------------------------------------------------------------------------

[_licensed] void AverageRepeatEx_VVU(VV,    // Reference VV
                                     VV,    // Data VV to average
                                     int);  // VVU_MODE


  
//-----------------------------------------------------------------------------------------------------------
// AverageRepeat2_VVU Average repeat values based on 2 reference channels.
//
// Notes              Repeated values in the reference VV will be averaged
//                    in the data VV.  The first value in the data VV will be set to the
//                    average and subsequent data VV values will be dummied out.
//                    Data is processed only to the minimum length of the
//                    input VV lengths.
//                    Both the reference VV values must repeat for the averaging
//                    to occur. This version is useful for averaging on repeated
//                    (X,Y) locations.
//
// See also           RemoveDummy_VV
//
// Available          5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void AverageRepeat2_VVU(VV,   // Reference VV
                                    VV,   // Reference VV
                                    VV);  // Data VV to average


  
//-----------------------------------------------------------------------------------------------------------
// AverageRepeat2Ex_VVU Average repeat values based on 2 reference channels.
//
// Notes                Repeated values in the reference VV will be set to the mean, median, minimum or maximum value
//                      in the data VV.  The first value in the data VV will be reset and subsequent data VV values will be dummied out.
//                      Data is processed only to the minimum length of the
//                      input VV lengths.
//                      Both the reference VV values must repeat for the averaging
//                      to occur. This version is useful for averaging on repeated
//                      (X,Y) locations.
//
// See also             RemoveDummy_VV
//
// Available            8.0.1
//-----------------------------------------------------------------------------------------------------------

[_licensed] void AverageRepeat2Ex_VVU(VV,    // Reference VV
                                      VV,    // Reference VV
                                      VV,    // Data VV to average
                                      int);  // VVU_MODE


  
//-----------------------------------------------------------------------------------------------------------
// BinarySearch_VVU Search  numeric value in a VV.
//
// Notes            The VV should be sorted.Search comparison is made on double
//                  comparison of the data.
//
// Available        7.1
//-----------------------------------------------------------------------------------------------------------

[_licensed] void BinarySearch_VVU(VV,        //
                                  real,      // Value to search for.
                                  var int,   // Minimum Location
                                  var int);  // Maximum Location


  
//-----------------------------------------------------------------------------------------------------------
// BoxCox_VVU Run Box-Cox (lambda) Transformation on VV.
//
// Available  5.1.8
//-----------------------------------------------------------------------------------------------------------

[_licensed] void BoxCox_VVU(VV,     // [i/o] VV
                            real);  // [i] Lambda Value


  
//-----------------------------------------------------------------------------------------------------------
// BPFilt_VVU Band-pass filter to the specified.
//
// Notes      If the short and long wavelengths are <= 0, the input channel
//            is simply copied to the output channel without filtering.
//            
//            The wavelengths are in fiducials.
//
// Available  5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void BPFilt_VVU(VV,     // Input VV
                            VV,     // Filtered VV
                            real,   // Short wavelength cutoff, 0 for highpass
                            real,   // Long wavelength cutoff, 0 for lowpass
                            int);   // Filter Length, 0 for default length


  
//-----------------------------------------------------------------------------------------------------------
// Clip_VVU Clip a VV to a range.
//
// Available 5.0
//-----------------------------------------------------------------------------------------------------------

[_public] void Clip_VVU(VV,     // VV to clip
                        real,   // Minimum value, rDUMMY for no minimum clip
                        real,   // Maximum value, rDUMMY for no maximum clip
                        int);   // VVU_CLIP


  
//-----------------------------------------------------------------------------------------------------------
// ClipToDetectLimit_VVU Apply detection limit clipping of data.
//
// Notes                 Flow:
//                       
//                       1. If auto-converting negatives, then all negative values
//                           are replaced by -0.5*value, and detection limit is ignored.
//                       
//                       2. If not auto-converting negatives, and the detection limit is not
//                          rDUMMY, then values less than the detection limit are converted to
//                          one-half the detection limit.
//                       
//                       This function is identical to ClipToDetectLimit_CHIMERA.
//
// Available             5.1.6
//-----------------------------------------------------------------------------------------------------------

[_licensed] void ClipToDetectLimit_VVU(VV,     // Input data vv (altered).
                                       real,   // Detection limit
                                       int);   // Auto-convert negatives?


  
//-----------------------------------------------------------------------------------------------------------
// Decimate_VVU Decimate a VV.
//
// Notes        For a decimation factor N, will remove all values except
//              those with indices equal to MN, where M is an integer.
//
// Available    6.1
//-----------------------------------------------------------------------------------------------------------

[_licensed] void Decimate_VVU(VV,    //
                              int);  // Decimation factor (must be > 0)


  
//-----------------------------------------------------------------------------------------------------------
// Deviation_VVU Calculate distance of point locations to a straight line
//
// Available     5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void Deviation_VVU(VV,     // X VV,REAL VV
                               VV,     // Y VV,REAL VV
                               VV,     // Output deviation VV,REAL VV
                               real,   // X of 1st point to define straight line
                               real,   // Y of 1st point to define straight line
                               real,   // X of 2nd point or line azimuth in degrees (North is 0 degree)
                               real,   // Y of 2nd point or GS_R8DM if line azimuth is defined
                               int);   // VVU_LINE


  
//-----------------------------------------------------------------------------------------------------------
// Distance_VVU Create a cumulative distance VV
//
// Available    5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void Distance_VVU(VV,     // X VV,REAL VV
                              VV,     // Y VV,REAL VV
                              VV,     // Output distance VV,REAL VV
                              real,   // X VV fid start
                              real,   // X VV fid incr
                              real,   // Y VV fid start
                              real);  // Y VV fid incr


  
//-----------------------------------------------------------------------------------------------------------
// DistanceLinkNonDummies_VVU Create distance linking non-dummies VV
//
// Available                  2022.2
//-----------------------------------------------------------------------------------------------------------

[_licensed] void DistanceLinkNonDummies_VVU(VV,     // X VV,REAL VV
                                            VV,     // Y VV,REAL VV
                                            VV,     // Output distance VV,REAL VV
                                            real,   // X VV fid start
                                            real,   // X VV fid incr
                                            real,   // Y VV fid start
                                            real);  // Y VV fid incr


  
//-----------------------------------------------------------------------------------------------------------
// DistanceNonCumulative_VVU Create a non cumulative distance VV i.e each
//                           distance element is the distance of the corresponding
//                           (X,Y) element and the previous element.
//
// Notes                     The fist distace element is rDUMMY.
//
// Available                 7.2
//-----------------------------------------------------------------------------------------------------------

[_licensed] void DistanceNonCumulative_VVU(VV,     // X VV,REAL VV
                                           VV,     // Y VV,REAL VV
                                           VV,     // Output distance VV,REAL VV
                                           real,   // X VV fid start
                                           real,   // X VV fid incr
                                           real,   // Y VV fid start
                                           real);  // Y VV fid incr


  
//-----------------------------------------------------------------------------------------------------------
// Distance3D_VVU Create a cumulative distance VV from X, Y and Z VVs
//
// Notes          The output VV is the length of the shortest X,Y or Z input VV.
//                Any values with dummies are ignored - the distance at that
//                point is equal to the distance at the previous valid point.
//                The returned VV is the cumulative straight-line distance
//                between the points. No re-sampling is performed.
//                VVs of any type are supported.
//
// Available      8.0.1
//-----------------------------------------------------------------------------------------------------------

[_licensed] void Distance3D_VVU(VV,     // X VV,REAL VV
                                VV,     // Y VV,REAL VV
                                VV,     // Z VV,REAL VV
                                real,   // Distance at first location
                                VV);    // Output distance VV,REAL VV


  
//-----------------------------------------------------------------------------------------------------------
// FindGaps3D_VVU Return indices of locations separated from previous locations by more than the input gap distance.
//
// Notes          Locate the starting points of line segements determined by an input gap distance.
//                The returned indices indicate where to break the line, given an input gap.
//                The number of returned indices is one less than the number of line segments.
//                (So if there are no gaps the returned VV has zero length).
//
// Available      8.1
//-----------------------------------------------------------------------------------------------------------

[_licensed] void FindGaps3D_VVU(VV,     // X VV,REAL VV
                                VV,     // Y VV,REAL VV
                                VV,     // Z VV,REAL VV
                                real,   // Gap size (must be greater than zero)
                                VV);    // Returned indices of start of sections after gaps (INT VV)


  
//-----------------------------------------------------------------------------------------------------------
// DummyRange_VVU Dummy values inside or outside a range in a VV
//
// Notes          If the Inside flag is TRUE, values within the specified
//                range are set to dummy. If the inside flag is FALSE,
//                values outside the range are set to dummy.  If the Inclusive
//                flag is TRUE, then dMin and dMax are considered part of the
//                range. If it is FALSE, then < or > are used, and dMin and
//                dMax lie outside the range.
//
// Available      5.0
//-----------------------------------------------------------------------------------------------------------

[_public] void DummyRange_VVU(VV,     // VV handle
                              real,   // Minimum range value
                              real,   // Maximum range value
                              int,    // If TRUE, dummy inside the range
                              int);   // If TRUE, include Min, Max in the range.


  
//-----------------------------------------------------------------------------------------------------------
// DummyRangeEx_VVU Like DummyRangeVVU, with inclusion options for both ends.
//
// Notes            If the Inside flag is TRUE, values within the specified
//                  range are set to dummy. If the inside flag is FALSE,
//                  values outside the range are set to dummy.  If the Inclusive
//                  flag is TRUE, then dMin and dMax are considered part of the
//                  range. If it is FALSE, then < or > are used, and dMin and
//                  dMax lie outside the range.
//
// Available        5.0.7
//-----------------------------------------------------------------------------------------------------------

[_public] void DummyRangeEx_VVU(VV,     // VV handle
                                real,   // Minimum range value
                                real,   // Maximum range value
                                int,    // If TRUE, dummy inside the range
                                int,    // If TRUE, include Min in the range.
                                int);   // If TRUE, include Max in the range.


  
//-----------------------------------------------------------------------------------------------------------
// DummyRepeat_VVU Dummy repeat values in a VV.
//
// Notes           Either the first, middle or last point will be left.
//                                   Use Interp_VVU to interpolate after if desired.
//
// Available       5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void DummyRepeat_VVU(VV,    //
                                 int);  // VVU_DUMMYREPEAT


  
//-----------------------------------------------------------------------------------------------------------
// DupStats_VVU Calculate means and differences for duplicate sample pairs
//
// Notes        Created for duplicate sample handling in CHIMERA. On input,
//              a numeric VV containing data values, and a sample type VV.
//              Sample pairs have types "1" and "2". This routine searches for
//              types in order "1 2 1 2", and writes the mean values of pairs
//              to the mean value VV, and the differences with the mean (equal
//              values, negative and positive) to the difference VV. Results
//              for samples out of order, for unmatched values, or when the
//              sample type does not equal "1" or "2" are set to dummy.
//
// Available    5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void DupStats_VVU(VV,   // Duplicate data VV
                              VV,   // Sample Type VV
                              VV,   // Mean values VV (returned)
                              VV);  // Diff values VV (returned)


  
//-----------------------------------------------------------------------------------------------------------
// ExpDist_VVU Fill with exponentially distributed values.
//
// Notes       VV is set to input length (except for -1)
//             See RAND for a short discription of the
//             random number generator used.
//
// Available   5.1.8
//-----------------------------------------------------------------------------------------------------------

[_licensed] void ExpDist_VVU(VV,     // VV object
                             int,    // Random number generator seed
                             real,   // Mean value of distribution (> 0.0)
                             int);   // Number of values (-1 for all)


  
//-----------------------------------------------------------------------------------------------------------
// Filter_VVU Apply a convolution filter to a VV.
//
// Available  5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void Filter_VVU(VV,       // Input VV
                            VV,       // Filtered VV
                            FILTER);  // Filter handle (see FLT)


  
//-----------------------------------------------------------------------------------------------------------
// FindStringItems_VVU Searches a VV for items in a second VV, returns indices of those found.
//
// Notes               This is a much more efficient way of determining if items in
//                     one VV are found in a second, than by searching
//                     repeatedly in a loop.
//                     The returned GS_LONG VV contains the same number of items as
//                     the "search items" VV, and contains -1 for items where the
//                     value is not found, and the index of items that are found.
//                     Comparisons are case-tolerant.
//                     Non-string VVs are converted to string type VVs (element size 24) internally.
//                     
//                     The method requires that the VV items be sorted, and
//                     will do so internally. Since the input VVs may already be sorted,
//                     the method will run faster if this stage can be skipped.
//
// Available           7.3
//-----------------------------------------------------------------------------------------------------------

[_licensed] void FindStringItems_VVU(VV,    // String VV in which to locate items
                                     VV,    // String VV Items to search for
                                     int,   // Is the first VV already sorted?
                                     int,   // Is the second VV already sorted
                                     int,   // Case tolerance for string comparisons
                                     VV);   // GS_LONG VV of returned indices into the first LST.


  
//-----------------------------------------------------------------------------------------------------------
// FractalFilter_VVU Fractal filter a VV.
//
// Available         6.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void FractalFilter_VVU(VV,    // [i] VV
                                   int,   // [i] filter order
                                   int,   // [i] filter number
                                   VV);   // [o] filtered VV


  
//-----------------------------------------------------------------------------------------------------------
// iCloseXY_VVU Find the closest point to an input point (XY).
//
// Returns      Index of closest point, -1 if no valid locations, or data is masked.
//
// Notes        Input X and Y location VVs, and a location.
//              Returns the index of the point in the VV closest to the
//              input point.
//
// Available    5.1.8
//-----------------------------------------------------------------------------------------------------------

[_licensed] int iCloseXY_VVU(VV,     // X locations
                             VV,     // Y locations
                             real,   // Input X
                             real);  // Input Y


  
//-----------------------------------------------------------------------------------------------------------
// iCloseXYM_VVU Find the closest point to an input point, with mask (XY).
//
// Returns       Index of closest point, -1 if no valid locations, or data is masked.
//
// Notes         Input X and Y location VVs, and a location.
//               Returns the index of the point in the VV closest to the
//               input point.
//               This skips points where the mask value is dummy.
//               If no valid points are in the VVs, or all the mask VV values
//               are dummy, the returned index is -1.
//
// Available     5.1.8
//-----------------------------------------------------------------------------------------------------------

[_licensed] int iCloseXYM_VVU(VV,     // X locations
                              VV,     // Y locations
                              VV,     // Mask values
                              real,   // Input X
                              real);  // Input Y


  
//-----------------------------------------------------------------------------------------------------------
// iCloseXYZ_VVU Find the closest point to an input point (XYZ).
//
// Returns       Index of closest point, -1 if no valid locations, or data is masked.
//
// Notes         Input X, Y and Z location VVs, and a location.
//               Returns the index of the point in the VV closest to the
//               input point.
//
// Available     5.1.8
//-----------------------------------------------------------------------------------------------------------

[_licensed] int iCloseXYZ_VVU(VV,     // X locations
                              VV,     // Y locations
                              VV,     // Z locations
                              real,   // Input X
                              real,   // Input Y
                              real);  // Input Z


  
//-----------------------------------------------------------------------------------------------------------
// iCloseXYZM_VVU Find the closest point to an input point, with mask (XYZ).
//
// Returns        Index of closest point, -1 if no valid locations, or data is masked.
//
// Notes          Input X, Y and Z location VVs, and a location.
//                Returns the index of the point in the VV closest to the
//                input point.
//                This skips points where the mask value is dummy.
//                If no valid points are in the VVs, or all the mask VV values
//                are dummy, the returned index is -1.
//
// Available      5.1.8
//-----------------------------------------------------------------------------------------------------------

[_licensed] int iCloseXYZM_VVU(VV,     // X locations
                               VV,     // Y locations
                               VV,     // Z locations
                               VV,     // Mask values
                               real,   // Input X
                               real,   // Input Y
                               real);  // Input Z


  
//-----------------------------------------------------------------------------------------------------------
// iDummyBackTracks_VVU Dummy all points that keep a VV from being monotonically increasing.
//
// Returns              The number of items dummied in order to render the VV montonically increasing.
//
// Notes                The VV length remains the same. Any point that is less than or equal to
//                      the previous (valid) point in the VV is dummied.
//
// Available            7.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] int iDummyBackTracks_VVU(VV);  // VV handle


  
//-----------------------------------------------------------------------------------------------------------
// iFindDummy_VVU Find the first dummy|non-dummy value in VV
//
// Returns        The index of the first dummy|non-dummy value in VV
//                -1 if not found or if length of VV is 0
//
// Notes          Start and end of range are always defined lowest
//                to largest even if decreasing search order.  To search
//                entire VV range, specify 0,-1.
//
// Available      5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] int iFindDummy_VVU(VV,    // VV handle
                               int,   // 0 increasing order 1 decreasing order
                               int,   // 0 to find the first dummy 1 find first non-dummy
                               int,   // Start search range at element
                               int);  // End search range at element (-1 for last)


  
//-----------------------------------------------------------------------------------------------------------
// Interp_VVU Replace all dummies by interpolating from valid data.
//
// Notes      Edge behaviour
//                 Dummies at the ends are treated as follows
//                 for various combinations of the inside and outside interpolation
//                 choices:
//            
//            ::
//            
//              if ((iOutside==VV_INTERP_EDGE_NEAREST) ||
//                  (iOutside==VV_INTERP_EDGE_SAME && iInside==VV_INTERP_NEAREST))
//            
//                   // -- Set dummies to the same value as the last defined element
//            
//              else if ((iOutside==VV_INTERP_EDGE_LINEAR) ||
//                       (iOutside==VV_INTERP_EDGE_SAME &&  iInside==VV_INTERP_LINEAR))
//            
//                   // --- Set dummies using the slope of the last two defined elements
//            
//              endif
//            
//            In all other cases and combinations of the two interpolation
//            choices, the dummies are left "as is".
//
// Available  5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void Interp_VVU(VV,    // Input VV
                            int,   // VVU_INTERP
                            int);  // VVU_INTERP_EDGE


  
//-----------------------------------------------------------------------------------------------------------
// iQCFillGaps_VVU Calculate fill in line segments
//
// Returns         1 if error, 0 if successful
//
// Notes           The X & Y VVs are returned as the calculated fill in line segments.
//
// Available       6.3
//-----------------------------------------------------------------------------------------------------------

[_licensed] int iQCFillGaps_VVU(VV,     // Input/output X VV on which to operate Required in GS_DOUBLE or GS_FLOAT
                                VV,     // Input/output Y VV on which to operate In GS_DOUBLE or GS_FLOAT
                                VV,     // Input Flag VV Required in GS_BYTE
                                VV,     // Input Gap VV to use for locating the fill inline segments In GS_DOUBLE or GS_FLOAT
                                real);  // Min segment length  (required)


  
//-----------------------------------------------------------------------------------------------------------
// iSearchText_VVU Search for a text value in a VV
//
// Returns         Index of first matching text, -1 if not found.
//
// Notes           Search comparison is made on string comparison
//                 of the data. Returns index of first item matching
//                 the input string.
//                 If start index is -1 or dummy, then full VV is searched.
//                 Use VVU_MATCH_INPUT_LENGTH to match the first part of a string.
//                 This is also recommended for matching numerical values, since
//                 the displayed value in the database may not be the same as the
//                 stored value.
//
// See also        sSearchReplace_VV
//
// Available       5.0.8
//-----------------------------------------------------------------------------------------------------------

[_licensed] int iSearchText_VVU(VV,       // VV to search
                                string,   // Text to match
                                int,      // VVU_CASE
                                int,      // VVU_MATCH
                                int,      // Index to begin search (-1 for full VV)
                                int);     // 1: forward search, -1: backward search


  
//-----------------------------------------------------------------------------------------------------------
// Mask_VVU Mask dummies in one VV onto another.
//
// Notes    VV to mask will be resampled to reference VV if required.
//          The returned length of the VV to mask will be the shorter
//          of the reference VV or the mask VV.
//
// Available 5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void Mask_VVU(VV,   // VV to be masked
                          VV);  // Mask reference VV


  
//-----------------------------------------------------------------------------------------------------------
// MaskAND_VVU Create mask from logical AND of two VVs.
//
// Notes       If both values are non-dummies, then result is 1, else dummy.
//
// Available   5.1.8
//-----------------------------------------------------------------------------------------------------------

[_licensed] void MaskAND_VVU(VV,   // VV A
                             VV,   // VV B
                             VV);  // VV C (returned)


  
//-----------------------------------------------------------------------------------------------------------
// MaskOR_VVU Create mask from logical OR of two VVs.
//
// Notes      If either values is non-dummy, then result is 1, else dummy.
//
// Available  5.1.8
//-----------------------------------------------------------------------------------------------------------

[_licensed] void MaskOR_VVU(VV,   // VV A
                            VV,   // VV B
                            VV);  // VV C (returned)


  
//-----------------------------------------------------------------------------------------------------------
// NLFilt_VVU Applies a non-linear filter.
//
// Available  5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void NLFilt_VVU(VV,     // Input VV
                            VV,     // Filtered VV
                            int,    // Filter Width
                            real);  // Filter Tolerance, 0 for 1% of Std. Dev.


  
//-----------------------------------------------------------------------------------------------------------
// NoiseCheck_VVU Check on deviation of data from variable background in a VV
//
// Notes          This function checks vertical deviation of data in input VV
//                against a moving straight line. The straight line at any time is
//                defined by two extreme points of a data segment.  Output VV will
//                be 0 if data point in input VV falls within the deviation,
//                otherwise, it will be 1.
//                Output VV will be 0 if the straight line is vertical.
//
// Available      5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void NoiseCheck_VVU(VV,     // Input VV on which to apply quality control Required in GS_DOUBLE or GS_FLOAT
                                VV,     // Output flag VV with result 0 and 1. Required in GS_BYTE
                                real,   // Allowed deviation over a number of data points in input VV (next parameter). Must be >= 0.0
                                int);   // Number of data points. Must be > 0


  
//-----------------------------------------------------------------------------------------------------------
// NoiseCheck2_VVU Like NoiseCheck_VVU, but returns maximum deviation at all points.
//
// Notes           This function checks vertical deviation of data in an input VV
//                 against a moving straight line, where the X-axis value is
//                 taken to be the data index, and the Y-axis value is the
//                 input data VV value. The straight line is drawn between data points
//                 at the ends of the line segment, whose length is an input.
//                 
//                 The output flag VV is set to 0 if data point in input VV falls within the
//                 deviation for all the moving line segments of which it is a part, otherwise, it
//                 will be set to 1.
//                 
//                 The output maximum deviation VV contains the maximum deviation at each point
//                 for all the moving line segments that it is a part of.
//
// Available       6.3
//-----------------------------------------------------------------------------------------------------------

[_licensed] void NoiseCheck2_VVU(VV,     // Input VV on which to apply quality control Required in GS_DOUBLE or GS_FLOAT
                                 VV,     // Output flag VV with result 0 and 1. Required in GS_BYTE
                                 VV,     // Output maximum deviation VV.
                                 real,   // Allowed deviation over a number of data points in input VV (next parameter). Must be >= 0.0
                                 int);   // Number of data points in the line segment. Must be > 0


  
//-----------------------------------------------------------------------------------------------------------
// NormalDist_VVU Fill with normally (Gaussian) distributed values.
//
// Notes          VV is set to input length (except for -1)
//                See RAND for a short discription of the
//                random number generator used.
//
// Available      5.1.8
//-----------------------------------------------------------------------------------------------------------

[_licensed] void NormalDist_VVU(VV,     // VV object
                                int,    // Random number generator seed
                                real,   // Mean value of distribution
                                real,   // Variance of the distribution
                                int);   // Number of values (-1 for all)


  
//-----------------------------------------------------------------------------------------------------------
// OffsetCircles_VVU Get non-overlapping offset location for circular symbols.
//
// Notes             Often on maps plotted symbols and text overlap each other.
//                   This routine accepts of VV of locations and returns a new
//                   set of locations offset from the originals, and guaranteed
//                   not to overlap, given the size of the original symbols.
//                   The returned offset X, Y
//                   locations are offset from the original locations by
//                   the minimum of a) the input offset, b) the input symbol
//                   radius. This is to ensure that the original location is
//                   never covered by the offset symbol.
//                   
//                   Care should be taken when choosing the symbol size, because
//                   if the point density is too high, all the points will get
//                   pushed to the outside edge and your plot will look like a
//                   hedgehog (it also takes a lot longer!).
//
// Available         5.0.7
//-----------------------------------------------------------------------------------------------------------

[_licensed] void OffsetCircles_VVU(VV,     // Input X locations
                                   VV,     // Input Y locations
                                   real,   // Minimum offset distance
                                   real,   // Symbol radius
                                   VV,     // Output (offset) X locations
                                   VV);    // Output (offset) Y locations


  
//-----------------------------------------------------------------------------------------------------------
// OffsetCorrect_VVU Correct locations based on heading and fixed offset.
//
// Notes             In many applications, measurements are taken with an instrument which
//                   is towed behind, or pushed ahead of where the locations are recorded.
//                   Use this function to estimate the actual location of the instrument.
//                   The method determines the heading along the line, using a "thinned"
//                   version of the line. The degree of thinning is based on the size of the
//                   offset; the larger the offset, the greater the distance between sample
//                   locations used to construct the thinned lined used for determining headings.
//                   The thinned line is splined at a frequency greater than the sample
//                   frequency, and the heading at any given point is determined from the
//                   vector formed by the closest two points on the splined line. The
//                   correction (behind, in front, left or right) is determined with respect
//                   to the heading, and added to the original location.
//                   
//                   IF this method fails, no dummies, no duplicated locations, no reversals
//                   are produced.
//                   
//                   The algorithm:
//                   
//                       1. Determine average distance between each point = D
//                       2. Smoothing interval = MAX(2*D, Offset distance) = I
//                       3. Thin input points to be at least the smoothing interval I apart from each other.
//                       4. Smoothly re-interpolate the thinned points at five times the
//                          original average distance D.
//                       5. For each input point, calculate the bearing using the nearest points
//                          on the smoothed curve
//
// Available         5.0.8
//-----------------------------------------------------------------------------------------------------------

[_licensed] void OffsetCorrect_VVU(VV,     // Input X
                                   VV,     // Input Y
                                   real,   // Offset distance
                                   int,    // VVU_OFFSET
                                   VV,     // Output X
                                   VV);    // Output Y


  
//-----------------------------------------------------------------------------------------------------------
// OffsetCorrect2_VVU Same as OffsetCorrect_VVU, but for an arbitrary offset angle.
//
// Available          5.1.3
//-----------------------------------------------------------------------------------------------------------

[_licensed] void OffsetCorrect2_VVU(VV,     // Input X
                                    VV,     // Input Y
                                    real,   // Offset distance
                                    real,   // Offset azimuth (degrees counter-clockwise from straight ahead)
                                    VV,     // Output X
                                    VV);    // Output Y


  
//-----------------------------------------------------------------------------------------------------------
// OffsetCorrect3_VVU Same as OffsetCorrect2_VVU, but specify smoothing interval.
//
// Notes              See the algorithm note #2 above for the default smoothing interval.
//
// Available          5.1.4
//-----------------------------------------------------------------------------------------------------------

[_licensed] void OffsetCorrect3_VVU(VV,     // Input X
                                    VV,     // Input Y
                                    real,   // Offset distance
                                    real,   // Offset azimuth (degrees counter-clockwise from straight ahead)
                                    real,   // Averaging interval - rDUMMY for default
                                    VV,     // Output X
                                    VV);    // Output Y


  
//-----------------------------------------------------------------------------------------------------------
// OffsetCorrectXYZ_VVU Correct locations based on heading and fixed offset.
//
// Notes                In many applications, measurements are taken with an instrument which
//                      is towed behind, or pushed ahead of where the locations are recorded.
//                      Use this function to estimate the actual location of the instrument.
//                      The method determines the heading along the line, using a "thinned"
//                      version of the line. The default degree of thinning is based on the size of the
//                      offset; the larger the offset, the greater the distance between sample
//                      locations used to construct the thinned lined used for determining headings.
//                      The thinned line is splined at a frequency greater than the sample
//                      frequency, and the heading at any given point is determined from the
//                      vector formed by the closest two points on the splined line. The
//                      correction (behind, in front, left or right) is determined with respect
//                      to the heading, and added to the original location.
//                      
//                      IF this method fails, no dummies, no duplicated locations, no reversals
//                      are produced.
//                      
//                      The algorithm:
//                      
//                          1. Determine average distance between each point = D
//                          2. Default smoothing interval = MAX(2*D, Offset distance) = I
//                          3. Thin input points to be at least the smoothing interval I apart from each other.
//                          4. Smoothly re-interpolate the thinned points at five times the
//                             original average distance D.
//                          5. For each input point, calculate the bearing using the nearest points
//                             on the smoothed curve
//
// Available            9.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void OffsetCorrectXYZ_VVU(VV,     // Input X
                                      VV,     // Input Y
                                      VV,     // Input Z
                                      real,   // Offset along-track (+ve forward)
                                      real,   // Offset across-track (+ve to the right)
                                      real,   // Vertical Offset (+ve up)
                                      real,   // Sampling interval - rDUMMY for default
                                      VV,     // Output X
                                      VV,     // Output Y
                                      VV);    // Output Z


  
//-----------------------------------------------------------------------------------------------------------
// OffsetRectangles_VVU Get non-overlapping offset location for rectangular symbols.
//
// Notes                Often on maps plotted symbols and text overlap each other.
//                      This routine accepts of VV of locations and returns a new
//                      set of locations offset from the originals, and guaranteed
//                      not to overlap, given the size of the original symbols.
//                      The returned offset X, Y
//                      locations are offset from the original locations by
//                      the minimum of a) the input offset, b) the input symbol
//                      X or Y size. This is to ensure that the original location is
//                      never covered by the offset symbol. In addition, the offset
//                      symbol is never place directly below the original location,
//                      to make it easier to draw a connecting line.
//                      
//                      Care should be taken when choosing the symbol size, because
//                      if the point density is too high, all the points will get
//                      pushed to the outside edge and your plot will look like a
//                      hedgehog (it also takes a lot longer!).
//
// Available            5.0.7
//-----------------------------------------------------------------------------------------------------------

[_licensed] void OffsetRectangles_VVU(VV,     // Input X locations
                                      VV,     // Input Y locations
                                      real,   // Minimum offset distance
                                      real,   // Symbol X size (width)
                                      real,   // Symbol Y size (height)
                                      VV,     // Output (offset) X locations
                                      VV);    // Output (offset) Y locations


  
//-----------------------------------------------------------------------------------------------------------
// PickPeak_VVU Find peaks in a VV - method one.
//
// Notes        Peaks are the maximum point within a sequence of
//              positive values in the input VV.  The width is the
//              number of points in the positive sequence.
//              
//              A VV may have to be pre-filtered before finding
//              the peak values:
//              
//              Use BPFilt_VVU to smooth the data as required.
//              Use Filter_VVU to apply a Laplace filter
//              "-0.5,1.0,-0.5" to make curvature data.
//
// Available    5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void PickPeak_VVU(VV,     // Input VV
                              VV,     // Returned peak VV, all dummies except peak points.
                              real,   // Minimum value to accept (0.0 to find all)
                              int);   // Minimum width to accept (1 to find all)


  
//-----------------------------------------------------------------------------------------------------------
// PickPeak2_VVU Find peaks in a VV - method two.
//
// Notes         Peaks are the maximum point within a sequence of
//               values in the input VV. Maximum points must be above
//               the base level and have a local amplitude greater
//               than the minimum amplitude specified.
//               
//               A VV may have to be pre-filtered before finding
//               the peak values.
//
// Available     5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void PickPeak2_VVU(VV,     // Input VV
                               VV,     // Returned peak VV, all dummies except peak points.
                               real,   // Base level to accept (0.0 to find all)
                               real);  // Minimum amplitude to accept


  
//-----------------------------------------------------------------------------------------------------------
// PickPeak3_VVU Find peaks in a VV - method two, returning width and half-amplitude widths.
//
// Notes         Uses Method 2 above, but also returns the anomaly width (defined
//               as the distance between the surrounding troughs), and the
//               width at the half-amplitude. The half-amplitude width is
//               calculated in two parts, individually for each side based on
//               the distance from the maximum to the location where the
//               amplitude is mid-way between the maximum and trough.
//               
//               The returned VVs are packed; no dummies. Instead the
//               indicies of the peak locations are returned.
//
// Available     6.2
//-----------------------------------------------------------------------------------------------------------

[_licensed] void PickPeak3_VVU(VV,     // [i] data VV
                               VV,     // [i] X VV used to calculate distance
                               VV,     // [i] Y VV used to calculate distance
                               real,   // [i] minimum value to accept (0.0 to find all)
                               real,   // [i] amplitude
                               VV,     // [o] Indices with peak locations
                               VV,     // [o] Amplitudes at the peaks
                               VV,     // [o] Anomaly widths
                               VV);    // [o] Anomaly half-amplitude widths


  
//-----------------------------------------------------------------------------------------------------------
// PolyFill_VVU Fill a VV with values from an n'th order polynomial, integral x.
//
// Notes        The output VV length must be set as desired before calling.
//              
//              The X scale is unitless (1 per element), i.e. 0,1,2,3,...
//
// See also     Trend_VVU, Trend2_VVU, PolyFill2_VVU
//
// Available    5.0.6
//-----------------------------------------------------------------------------------------------------------

[_licensed] void PolyFill_VVU(VV,    // VV with output data. (Preset length)
                              int,   // Order of the polynomial 0-9
                              VV);   // VV with polynomial coefficients (input)


  
//-----------------------------------------------------------------------------------------------------------
// PolyFill2_VVU Fill a VV with values from an n'th order polynomial, specified X
//
// Notes         The output VV length must be set as desired before calling.
//               The X scale is defined by a X VV (see Trend_VV for unitless X).
//
// See also      Trend_VVU, Trend2_VVU, PolyFill_VVU
//
// Available     5.0.6
//-----------------------------------------------------------------------------------------------------------

[_licensed] void PolyFill2_VVU(VV,    // VV with x spacing (input)
                               VV,    // VV with output data. (Preset length)
                               int,   // Order of the polynomial 0-9
                               VV);   // VV with polynomial coefficients (order+1 values)


  
//-----------------------------------------------------------------------------------------------------------
// PolygonMask_VVU Mask a VV using XY data and a polygon.
//
// Notes           The VVs have to be the same length
//
// Available       6.2
//-----------------------------------------------------------------------------------------------------------

[_licensed] void PolygonMask_VVU(VV,    // X VV
                                 VV,    // Y VV
                                 VV,    // VV to be masked
                                 PLY,   // PLY object
                                 int);  // VVU_MASK


  
//-----------------------------------------------------------------------------------------------------------
// Prune_VVU Prune values from a VV based on reference VV
//
// Notes     Pruning will shorten the VV by removing values
//           that are either dummy or non-dummy in the reference
//           VV
//
// Available 5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void Prune_VVU(VV,    // VV to prune
                           VV,    // Reference VV
                           int);  // VVU_PRUNE


  
//-----------------------------------------------------------------------------------------------------------
// QC_VVU Quality control on deviation of data from norm in a VV
//
// Notes  This function tests data in input VV against
//        two separate criteria. Each element of the output VV
//        will have one of the following indicators:
//        
//        =========  ==============================================================
//        Indicator  Meaning
//        =========  ==============================================================
//          0        Input data passed both tests
//        ---------  --------------------------------------------------------------
//          1        The input data and is greater than the nominal value
//                   plus maximum tolerance/deviation (Criterion #1)
//        ---------  --------------------------------------------------------------
//          2        The input data over a specified distance is greater than the
//                   nominal value plus allowed tolerance (Criterion #2)
//        ---------  --------------------------------------------------------------
//          3        The input data failed on above two tests
//        ---------  --------------------------------------------------------------
//         -1        The input data and is less than the nominal value
//                   minus maximum tolerance (Criterion #1)
//        ---------  --------------------------------------------------------------
//         -2        The input data over a specified distance is less than the
//                   nominal value minus allowed tolerance (Criterion #2)
//        ---------  --------------------------------------------------------------
//         -3        The input data failed on above two tests
//        =========  ==============================================================
//
// Available 5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void QC_VVU(VV,     // Input VV on which to apply quality control Required in GS_DOUBLE or GS_FLOAT
                        VV,     // Distance VV (NULL if criterion #2 does not apply). In GS_DOUBLE or GS_FLOAT
                        VV,     // Output flag VV with result 0,1,2,3,-1,-2,-3. Required in GS_BYTE
                        real,   // Nominal reading  (required, must not be GS_R8DM)
                        real,   // Maximum tolerance/deviation applied to a single reading (criterion #1). GS_R8DM if criterion #1 does not apply. Otherwise, must be positive value including 0.0
                        real,   // Allowed tolerance/deviation over a given distance (next parameter) (criterion #2). GS_R8DM if criterion #2 does not apply. Otherwise, must be positive value including 0.0
                        real,   // The specified distance. GS_R8DM if criterion #2 does not apply. Otherwise, must be positive value excluding 0.0
                        int);   // QC_CRITERION


  
//-----------------------------------------------------------------------------------------------------------
// QC2_VVU Quality control on deviation of data from norm in a VV
//
// Notes   This function tests data in input VV against
//         two separate criteria. Each element of the output VV
//         will have one of the following indicators:
//         
//         =========  ==============================================================
//         Indicator  Meaning
//         =========  ==============================================================
//           0        Input data passed both tests
//         ---------  --------------------------------------------------------------
//           1        The input data and is greater than the nominal value
//                    plus maximum tolerance/deviation (Criterion #1)
//         ---------  --------------------------------------------------------------
//           2        The input data over a specified distance is greater than the
//                    nominal value plus allowed tolerance (Criterion #2)
//         ---------  --------------------------------------------------------------
//           3        The input data failed on above two tests
//         ---------  --------------------------------------------------------------
//          -1        The input data and is less than the nominal value
//                    minus maximum tolerance (Criterion #1)
//         ---------  --------------------------------------------------------------
//          -2        The input data over a specified distance is less than the
//                    nominal value minus allowed tolerance (Criterion #2)
//         ---------  --------------------------------------------------------------
//          -3        The input data failed on above two tests
//         =========  ==============================================================
//
// Available 2022.2
//-----------------------------------------------------------------------------------------------------------

[_licensed] void QC2_VVU(VV,     // Input VV on which to apply quality control Required in GS_DOUBLE or GS_FLOAT
                         VV,     // Distance VV (NULL if criterion #2 does not apply). In GS_DOUBLE or GS_FLOAT
                         VV,     // Output flag VV with result 0,1,2,3,-1,-2,-3. Required in GS_BYTE
                         VV,     // Drape elevation VV which is used instead of a constant nominal terrain clearance Required in GS_DOUBLE or GS_FLOAT
                         real,   // Maximum tolerance/deviation applied to a single reading (criterion #1). GS_R8DM if criterion #1 does not apply. Otherwise, must be positive value including 0.0
                         real,   // Allowed tolerance/deviation over a given distance (next parameter) (criterion #2). GS_R8DM if criterion #2 does not apply. Otherwise, must be positive value including 0.0
                         real,   // The specified distance. GS_R8DM if criterion #2 does not apply. Otherwise, must be positive value excluding 0.0
                         int);   // QC_CRITERION


  
//-----------------------------------------------------------------------------------------------------------
// RangeVectorMag_VVU Find the range of hypotenuse values of two VVs.
//
// Notes              For each value in the VVs, finds sqrt(dV1*dV1 + dV2*dV2)
//                    and returns the min and max values.
//
// Available          5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void RangeVectorMag_VVU(VV,         // First VV (X)
                                    VV,         // First VV (Y)
                                    var real,   // Min value (returned)
                                    var real);  // Max value (returned)


  
//-----------------------------------------------------------------------------------------------------------
// Regress_VVU Calculate linear regression through data
//
// Available   5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void Regress_VVU(VV,         // X data
                             VV,         // Y data
                             var real,   // Returns slope
                             var real);  // Returns intercept


  
//-----------------------------------------------------------------------------------------------------------
// RelVarDup_VVU Estimate relative variance of duplicate sample pairs from a database.
//
// Notes         Created for duplicate sample handling in CHIMERA. On input,
//               a numeric or text VV containing data values, and a sample type VV.
//               Sample pairs have types "1" and "2". This routine searches for
//               types in order "1 2 1 2", and calulates the unnormalized relative variance,
//               defined as the sum of the squared differences between duplicates
//               divided by the sum of the squared mean values of the duplicates.
//               (To get the true rel.var., divide by N-1, where N is the number of
//               duplicate pairs used.)
//               Samples out of order, unmatched pairs, or when the
//               sample type does not equal "1" or "2" are ignored.
//
// Available     5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void RelVarDup_VVU(VV,         // Data VV
                               VV,         // Sample Type VV
                               var real,   // Returned relative variance
                               var int);   // Returned number of duplicates used.


  
//-----------------------------------------------------------------------------------------------------------
// RemoveDummy_VVU Remove dummy values from a VV
//
// Available       5.0
//-----------------------------------------------------------------------------------------------------------

[_public] void RemoveDummy_VVU(VV);  //


  
//-----------------------------------------------------------------------------------------------------------
// RemoveDummy2_VVU Remove dummy values from 2 VVs.
//
// Notes            Removes all indices where either VV has a dummy, or is
//                  not defined (due to length differences).
//
// Available        5.0.8
//-----------------------------------------------------------------------------------------------------------

[_licensed] void RemoveDummy2_VVU(VV,   // VV object
                                  VV);  // VV object


  
//-----------------------------------------------------------------------------------------------------------
// RemoveDummy3_VVU Remove dummy values from 3 VVs.
//
// Notes            Removes all indices where any VV has a dummy, or is
//                  not defined (due to length differences).
//
// Available        5.0.8
//-----------------------------------------------------------------------------------------------------------

[_licensed] void RemoveDummy3_VVU(VV,   // VV object
                                  VV,   // VV object
                                  VV);  // VV object


  
//-----------------------------------------------------------------------------------------------------------
// RemoveDummy4_VVU Remove dummy values from 4 VVs.
//
// Notes            Removes all indices where any VV has a dummy, or is
//                  not defined (due to length differences).
//
// Available        6.2
//-----------------------------------------------------------------------------------------------------------

[_licensed] void RemoveDummy4_VVU(VV,   // VV object
                                  VV,   // VV object
                                  VV,   // VV object
                                  VV);  // VV object


  
//-----------------------------------------------------------------------------------------------------------
// RemoveDup_VVU Remove/average duplicate sample pairs from a database.
//
// Notes         Created for duplicate sample handling in CHIMERA. On input,
//               a numeric or text VV containing data values, and a sample type VV.
//               Sample pairs have types "1" and "2". This routine searches for
//               types in order "1 2 1 2", and replaces the pair of values in the
//               data VV according to the VV_DUP value.
//               Results for samples out of order, for unmatched pairs, or when the
//               sample type does not equal "1" or "2" remain unchanged.
//
// Available     5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void RemoveDup_VVU(VV,    // Data VV
                               VV,    // Sample Type VV
                               int);  // VV_DUP


  
//-----------------------------------------------------------------------------------------------------------
// RemoveXYDup_VVU Remove/average duplicate samples with the same (X, Y).
//
// Notes           Searches for duplicated (X, Y) locations and removes the
//                 duplicates (can be more than just a pair). The "Z" values,
//                 if defined, are treated according to the value of VV_XYDUP.
//                 The returned VVs are shortened to the new length, without
//                 duplicates.
//                 The Z VV can be set to NULL on input, in which case it is ignored.
//
// Available       5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void RemoveXYDup_VVU(VV,    // X VV
                                 VV,    // Y VV
                                 VV,    // (optional) Z VV
                                 int);  // VV_XYDUP


  
//-----------------------------------------------------------------------------------------------------------
// RemoveXYDupIndex_VVU Remove duplicate samples with the same (X, Y) and update index.
//
// Notes                Searches for duplicated (X, Y) locations and removes the
//                      duplicates (can be more than just a pair). The Index VV is
//                      updated accordingly .i.e if  (X,Y) location of Index[0] == Index[1]
//                      Index[1] is removed.
//
// Available            7.2
//-----------------------------------------------------------------------------------------------------------

[_licensed] void RemoveXYDupIndex_VVU(VV,   // X VV
                                      VV,   // Y VV
                                      VV);  // Index VV


  
//-----------------------------------------------------------------------------------------------------------
// RollingStats_VVU Calculate a statistic in a rolling window.
//
// Notes            If the input VVs are not REAL, copies are made to
//                  temporary REALs for processing.
//                  
//                  If the window size is even, it is increased by 1 so that the
//                  output value is put at the exact center index of the window.
//                  
//                  Statistics are calculated on the values in a window
//                  surrounding the individual data points.
//                  
//                  By shrinking the window at the ends, one-sided effects can be
//                  eliminated. For instance, if the data is linear to begin with,
//                  a rolling mean will not alter the original data.
//                  However, if the window size is kept constant, then values
//                  near the ends tend to be pulled up or down.
//                  
//                  With shrinking, the window is shrunk so that it always has the
//                  same width on both sides of the data point under analysis;
//                  at the end points the window width is 1, at the next point in
//                  it is 3, and so on, until the full width is reached.
//                  
//                  The median value is calculated by sorting the valid data in
//                  the window, then selecting the middle value. If the number
//                  of valid data points is even, then the average of the two
//                  central values is returned.
//                  
//                  The mode value is defined as the value which occurs most
//                  frequently in the data. This value may not even exist, or
//                  may not be unique. In this implementation, the following
//                  algorithm is used: The valid data in the window is sorted
//                  in ascending order. The number of occurrences of each data
//                  value is tracked, and if it occurs more times than any
//                  value, it becomes the modal value. If all
//                  values are different, this procedure returns the smallest
//                  value. If two or more values each have the same (maximum)
//                  number of occurrences, then the smallest of these values is
//                  returned.
//
// Available        5.1
//-----------------------------------------------------------------------------------------------------------

[_licensed] void RollingStats_VVU(VV,    // Input VV
                                  VV,    // Output VV
                                  int,   // ST_INFO
                                  int,   // Window size (>0, increased to nearest odd value)
                                  int);  // Shrink window at ends (1:Yes, 0:No)


  
//-----------------------------------------------------------------------------------------------------------
// SearchReplace_VVU Search and replace numeric values in a VV.
//
// Notes             Search comparison is made on double comparison
//                   of the data.
//
// See also          SearchReplaceText_VV
//
// Available         5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void SearchReplace_VVU(VV,     //
                                   real,   // Value to replace
                                   real);  // Replacement


  
//-----------------------------------------------------------------------------------------------------------
// SearchReplaceText_VVU Search and replace text values in a VV
//
// Notes                 Search comparison is made on string comparison
//                       of the data.
//
// See also              SearchReplace_VV
//
// Available             5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void SearchReplaceText_VVU(VV,       //
                                       int,      // String format for numeric VV
                                       int,      // Decimals for formating numeric VV
                                       string,   // Formatted string to replace
                                       string,   // Replacement
                                       int);     // VVU_SRCHREPL_CASE


  
//-----------------------------------------------------------------------------------------------------------
// SearchReplaceTextEx_VVU Search and replace text values in a VV, count items changed.
//
// Notes                   Search comparison is made on a string comparison
//                         of the data.
//
// See also                SearchReplaceText_VV
//
// Available               6.0.1
//-----------------------------------------------------------------------------------------------------------

[_licensed] void SearchReplaceTextEx_VVU(VV,        //
                                         int,       // String format for numeric VV
                                         int,       // Decimals for formating numeric VV
                                         string,    // Formatted string to replace
                                         string,    // Replacement
                                         int,       // VVU_SRCHREPL_CASE
                                         var int);  // Number of items replaced (returned)


  
//-----------------------------------------------------------------------------------------------------------
// Spline_VVU Spline a Y VV onto an X VV.
//
// Available  5.0
//-----------------------------------------------------------------------------------------------------------

[_licensed] void Spline_VVU(VV,     // X (no dummies)
                            VV,     // Y to be splined (no dummies)
                            VV,     // Y output
                            int,    // Output Length
                            real,   // Starting Location
                            real,   // Separation Distance
                            real,   // Maximum gap to interpolate across
                            int,    // Number of elements to extend
                            int);   // VVU_SPL


  
//-----------------------------------------------------------------------------------------------------------
// Spline2_VVU Spline a Y VV onto an X VV. Uses specified values of X in X2
//
// Available   5.1.3
//-----------------------------------------------------------------------------------------------------------

[_licensed] void Spline2_VVU(VV,    // X (no dummies)
                             VV,    // Y to be splined (no dummies)
                             VV,    // X2 (no dummies)
                             VV,    // Y output
                             int);  // VVU_SPL


  
//-----------------------------------------------------------------------------------------------------------
// iTokenizeToValues_VVU Tokenize a string based on any characters.
//
// Returns               Number of tokens (length of VV)
//
// Notes                 Parses a series of space, tab or comma-delimited values to a VV.
//
// Available             9.0
//-----------------------------------------------------------------------------------------------------------

[_public] int iTokenizeToValues_VVU(VV,       // VV to place values in
                                    string);  // Str - String to parse


  
//-----------------------------------------------------------------------------------------------------------
// Translate_VVU Translate values in a VV
//
// Notes         (new VV) = ((old VV) + base) * scale
//
// Available     5.0
//-----------------------------------------------------------------------------------------------------------

[_public] void Translate_VVU(VV,     //
                             real,   // Base
                             real);  // Scale


  
//-----------------------------------------------------------------------------------------------------------
// Trend_VVU Calculate an n'th order best-fit polynomial, integral x.
//
// Notes     Returns coefficients c[0] .. c[n]
//           
//              Y(x) = c[0] + c[1]x + c[2](x**2) + ... + c[n](x**n)
//           
//           The X scale is unitless (1 per element), i.e. 0,1,2,3,...
//           
//           The polynomial VV length is set to the number of coefficients
//           (order + 1)
//
// See also  PolyFill_VVU, Trend2_VVU, PolyFill2_VVU
//
// Available 5.0.6
//-----------------------------------------------------------------------------------------------------------

[_licensed] void Trend_VVU(VV,    // VV with input data
                           int,   // Order of the polynomial 0-9
                           VV);   // VV to hold polynomial coefficients (returned).


  
//-----------------------------------------------------------------------------------------------------------
// Trend2_VVU Calculate an n'th order best-fit polynomial, specified X
//
// Notes      Returns coefficients c[0] .. c[n]
//            
//               Y(x) = c[0] + c[1]x + c[2](x**2) + ... + c[n](x**n)
//            
//            The X scale is defined by a X VV (see Trend_VV for unitless X).
//            
//            The polynomial VV length is set to the number of coefficients
//            (order + 1)
//
// See also   PolyFill_VVU, Trend2_VVU, PolyFill2_VVU
//
// Available  5.0.6
//-----------------------------------------------------------------------------------------------------------

[_licensed] void Trend2_VVU(VV,    // VV with x spacing (input)
                            VV,    // VV with input data
                            int,   // Order of the polynomial 0-9
                            VV);   // VV to hold polynomial coefficients (returned)


  
//-----------------------------------------------------------------------------------------------------------
// UniformDist_VVU Fill with uniformly distributed values.
//
// Notes           VV is set to input length (except for -1)
//                 See rand.gxh for a short discription of the
//                 random number generator used.
//
// Available       5.1.8
//-----------------------------------------------------------------------------------------------------------

[_licensed] void UniformDist_VVU(VV,     // VV object
                                 int,    // Random number generator seed
                                 real,   // Minimum of range
                                 real,   // Maximum of range
                                 int);   // Number of values (-1 for all)





//*** endblock Generated


#endif
